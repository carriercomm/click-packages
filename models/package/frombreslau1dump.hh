#ifndef CLICK_FROMBRESLAU1DUMP_HH
#define CLICK_FROMBRESLAU1DUMP_HH
#include <click/element.hh>
#include <click/task.hh>

/*
=c

FromBreslau1Dump(FILE [, I<KEYWORDS>])

=s sources

reads packets from a Breslau-format NetFlow dump file

=d

Reads IP packet descriptors from a file containing NetFlow data, in the ASCII
summary format described by Lee Breslau, then creates packets containing info
from the descriptors and pushes them out the output. Optionally stops the
driver when there are no more packets.

FILE may be compressed with gzip(1) or bzip2(1); FromIPSummaryDump will run
zcat(1) or bzcat(1) to uncompress it.

Keyword arguments are:

=over 8

=item STOP

Boolean. If true, then FromIPSummaryDump will ask the router to stop when it
is done reading. Default is false.

=item ACTIVE

Boolean. If false, then FromIPSummaryDump will not emit packets (until the
`C<active>' handler is written). Default is true.

=item ZERO

Boolean. Determines what is in any packet data not set by the dump. If true,
this data is zero. If false (the default), this data is random garbage.

=back

Only available in user-level processes.

=n

Packets generated by FromBreslau1Dump always have IP version 4 and IP header
length 5. The rest of the packet data is zero or garbage, unless set by the
dump. Generated packets will usually have incorrect lengths.

=h active read/write

Value is a Boolean.

=a

FromDump, FromIPSummaryDump */

class FromBreslau1Dump : public Element { public:

    FromBreslau1Dump();
    ~FromBreslau1Dump();

    const char *class_name() const	{ return "FromBreslau1Dump"; }
    const char *processing() const	{ return AGNOSTIC; }
    FromBreslau1Dump *clone() const	{ return new FromBreslau1Dump; }

    int configure(const Vector<String> &, ErrorHandler *);
    int initialize(ErrorHandler *);
    void uninitialize();
    void add_handlers();

    void run_scheduled();
    Packet *pull(int);

  private:

    static const uint32_t BUFFER_SIZE = 32768;
    
    int _fd;
    String _buffer;
    int _pos;
    int _len;

    Vector<int> _contents;
    
    bool _stop : 1;
    bool _format_complaint : 1;
    bool _zero;
    bool _active;

    Task _task;

    struct timeval _time_offset;
    String _filename;
    FILE *_pipe;

    int error_helper(ErrorHandler *, const char *);
    int read_buffer(ErrorHandler *);
    int read_line(String &, ErrorHandler *);

    Packet *read_packet(ErrorHandler *);

    static String read_handler(Element *, void *);
    static int write_handler(const String &, Element *, void *, ErrorHandler *);
    
};

#endif
