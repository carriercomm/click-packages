#!/usr/bin/env python

from __future__ import generators
import sys, re, types, string, struct, gzip
#sys.path[0:0] = ['/usr/lib/python2.2/site-packages/gtk-2.0']
from bisect import bisect
from math import *
import gtk, gobject, pango, xml.parsers.expat

class LineDescriptor:
    def __init__(self, r, g, b, **args):
        self.red = r
        self.green = g
        self.blue = b
        self.attrs = args
    def __getattr__(self, name):
        if name in self.attrs:
            return self.attrs[name]
        elif name == "dash":
            return []
        elif name == "linewidth":
            return 1

_screen_style = {
    "data": LineDescriptor(1, 0, 0),
    "ack": LineDescriptor(0.42, 0.56, 0.14),
    "dataack": LineDescriptor(0, 0, 1),
    "window": LineDescriptor(0.8, 0.8, 1, linewidth=2),
    
    "loss": LineDescriptor(1, 0.84, 0),
    "loss.bg": LineDescriptor(0.94, 0.90, 0.55),
    "ploss": LineDescriptor(0.56, 0.74, 0.56),
    "ploss.bg": LineDescriptor(0.66, 0.9, 0.66),
    "floss": LineDescriptor(0.8, 0.8, 0.8),
    "floss.bg": LineDescriptor(0.9, 0.9, 0.9),
    "lossborder": LineDescriptor(1, 1, 0, dash=[4, 4]),

    "border": LineDescriptor(0.66, 0.66, 0.66),
    "bg": LineDescriptor(1, 1, 1),
    "label": LineDescriptor(0.66, 0.66, 0.66),

    "highlight": LineDescriptor(1, 0.9, 0, linewidth=2)
    }

_postscript_style = {
    "data": LineDescriptor(1, 0, 0, linewidth=0.5),
    "ack": LineDescriptor(0.42, 0.56, 0.14, linewidth=0.5),
    "dataack": LineDescriptor(0, 0, 1, linewidth=0.5),
    "window": LineDescriptor(0.8, 0.8, 1, linewidth=1.5),
    
    "loss": LineDescriptor(1, 0.84, 0),
    "loss.bg": LineDescriptor(0.94, 0.90, 0.55),
    "ploss": LineDescriptor(0.56, 0.74, 0.56),
    "ploss.bg": LineDescriptor(0.66, 0.9, 0.66),
    "floss": LineDescriptor(0.8, 0.8, 0.8),
    "floss.bg": LineDescriptor(0.9, 0.9, 0.9),
    "lossborder": LineDescriptor(1, 1, 0, dash=[4, 4]),

    "border": LineDescriptor(0, 0, 0),
    "bg": LineDescriptor(1, 1, 1),
    "label": LineDescriptor(0, 0, 0)
    }


def frange(start, stop, step):
    i = 0
    while True:
        pos = start + i * step
        if pos > stop:
            break
        yield pos
        i += 1

def uncompressed_file(filename):
    f = file(filename, "rb")
    twochars = f.read(2)
    f.seek(0)
    if twochars == "\037\235" or twochars == "\037\213":
        return gzip.GzipFile(fileobj=f)
    else:
        return f

def stock_image(stock_id):
    image = gtk.Image()
    image.set_from_stock(stock_id, gtk.ICON_SIZE_SMALL_TOOLBAR)
    return image

def file_image(filename):
    image = gtk.Image()
    image.set_from_file(filename)
    return image

def bisect_with_cmp(list, cmp, lo=0, hi=None):
    if hi is None: hi = len(list)
    while lo < hi:
        mid = (lo + hi) // 2
        if cmp(list[mid]) < 0: hi = mid
        else: lo = mid + 1
    return lo

def union_rectangle(r1, r2):
    if r1 is None or r1[2] <= 0 or r1[3] <= 0: return r2
    if r2 is None or r2[2] <= 0 or r2[3] <= 0: return r1
    x, y = min(r1[0], r2[0]), min(r1[1], r2[1])
    return (x, y, max(r1[0] + r1[2], r2[0] + r2[2]) - x, max(r1[1] + r1[3], r2[1] + r2[3]) - y)

def expand_rectangle(r1, v):
    if r1 is None or r1[2] <= 0 or r1[3] <= 0: return r1
    return (r1[0] - v, r1[1] - v, r1[2] + 2*v, r1[3] + 2*v)

def ordinal(n):
    if abs(n) == 1: return str(n) + "st"
    elif abs(n) == 2: return str(n) + "nd"
    elif abs(n) == 3: return str(n) + "rd"
    else: return str(n) + "th"


class Packet:
    __slots__ = ['time', 'seq', 'last_seq', 'ack', 'dup_acks', 'window']
    def __init__(self, time, flags, seq, payloadlen, ack, dup_acks=0, window=0):
        self.time = time
        self.seq = seq
        self.last_seq = self.seq + payloadlen
        self.ack = ack
        if flags != "A" and flags != "PA":
            if flags.find("S") >= 0:
                self.last_seq += 1
            if flags.find("F") >= 0:
                self.last_seq += 1
        self.dup_acks = dup_acks
        self.window = window
    def pure_ack(self):
        return self.seq == self.last_seq
    def has_data(self):
        return self.seq != self.last_seq
    def __cmp__(self, other):
        return self.time.__cmp__(other.time)
    def __str__(self):
        result = "[" + str(self.time) + " "
        if self.pure_ack():
            result += "A" + str(self.ack)
        else:
            result += str(self.seq) + ":" + str(self.last_seq)
        return result + "]"

class LossEvent:
    def __init__(self, type, begin, seq, end, end_seq):
        self.type, self.begin, self.seq, self.end, self.end_seq = \
                   type, float(begin), float(seq), float(end), float(end_seq)
    def time_overlaps(self, begin, end):
        return (begin is None or self.end >= begin) and (end is None or end >= self.begin);
    def fillcolor(self):
        return fill_colors[self.type]


class ConnectionFormatError(Exception):
    def __init__(self, s=""):
        self.str = s
    def __str__(self):
        return `self.str`
class ConnectionFileCompressedError(ConnectionFormatError):
    def __init__(self, s=""):
        self.str = s
    def __str__(self):
        return `self.str`

def direction(dir):
    if dir == '>':
        return 0
    elif dir == '<':
        return 1
    elif dir is True:
        return 0
    elif dir is False:
        return 1
    elif int(dir) == 0 or int(dir) == 1:
        return int(dir)
    else:
        raise ConnectionFormatError, "bad direction " + `dir`


def unparse_tcp_flags(flags):
    return ("", "F", "S", "FS", "R", "FR", "SR", "FSR",
            "P", "FP", "SP", "FSP", "RP", "FRP", "SRP", "FSRP")[flags & 15] \
        + ("", "A", "U", "AU", "E", "AE", "UE", "AUE",
           "W", "AW", "UW", "AUW", "EW", "AEW", "UEW", "AUEW")[(flags >> 4) & 15]

class Connection:

    __slots__ = ['s', 'loss', 'available', 'flowid', 'aggregate', 'loss_count', 'filename']

    _field_unpack_format = {
        "ts_sec": "L", "ts_usec": "L", "ip_src": "L",
        "ip_dst": "L", "ip_len": "L", "ip_proto": "B", "ip_id": "H", "sport": "H",
        "dport": "H", "tcp_seq": "L", "tcp_ack": "L", "tcp_flags": "B", "payload_len": "L",
        "count": "L", "ip_frag": "B", "ip_fragoff": "H", "direction": "B",
        "aggregate": "L", "tcp_window": "H", "word_crap": "L"
        }
    _binary_size = { "L": 4, "H": 2, "B": 1 }
    _parse_code = None
    _parse_code_of = None
    _parse_code_min_binary_len = 0
    _parse_code_window = False
    
    def __init__(self, f=None, aggregate=-1, src=None, sport=None, dst=None, dport=None):
        self.s = ([], [])
        self.loss = ([], [])
        self.available = False
        if src is not None:
            self.flowid = (src, int(sport), dst, int(dport))
        else:
            self.flowid = None
        self.aggregate = aggregate
        self.loss_count = [0, 0]
        if type(f) == types.FileType:
            self.read(f)
        else:
            self.filename = f

    class Fileboy:
        def __init__(self, f):
            self.f = f
            self.str = ""
            self.pos = 0
        def __iter__(self):
            return self
        def next(self):
            while True:
                eol = self.str.find("\n", self.pos)
                if eol >= 0:
                    p, self.pos = self.pos, eol + 1
                    return self.str[p:self.pos]
                if self.pos > 0:
                    self.str = self.str[self.pos:]
                    self.pos = 0
                p = len(self.str)
                self.str += self.f.read(32768)
                if len(self.str) == 0:
                    raise StopIteration
                elif len(self.str) == p:
                    self.pos = p
                    return self.str
        def read(self):
            p, self.pos = self.pos, len(self.str)
            return self.str[p:] + self.f.read()
    
    def _check_data(self):
        # exit early if not active
        if self.read_state != "a" and self.read_state != "b":
            return

        # replace 'timestamp' with 'ts_sec ts_usec' if necessary
        line = self.read_data
        if self.read_state == "b":
            line = re.sub("\\btimestamp\\b", "ts_sec ts_usec", line)
            line = re.sub("\\bfirst_timestamp\\b", "word_crap word_crap", line)
        data = line[5:].split()

        # drop everything after the first field we don't understand 
        unpack_format = "!"; unpack_size = 0
        if self.read_state == "b":
            for i in range(0, len(data)):
                try:
                    f = Connection._field_unpack_format[data[i]]
                    unpack_format += f; unpack_size += Connection._binary_size[f]
                except KeyError:
                    data = data[:i]
                    break

        # exit early if possible
        if Connection._parse_code_of == (data, self.read_state):
            self.has_window = Connection._parse_code_window
            return

        # create mapping
        m = dict(zip(data, range(len(data))))

        # complain if important fields missing
        if ("timestamp" not in m and "ts_sec" not in m) or "direction" not in m or "tcp_seq" not in m:
            raise ConnectionFormatError, "bad !data missing important pieces"

        # create code
        if self.read_state == "b":
            code = 'fields = struct.unpack("' + unpack_format + '", data[pos+4:pos+' + str(unpack_size + 4) + '])\n'
            ifields = dict(map(lambda x: (x[0], 'fields[' + `x[1]` + ']'), m.items()))
            ffields = dict(map(lambda x: (x[0], 'float(fields[' + `x[1]` + '])'), m.items()))
        else:
            code = 'fields = line.split()\n'
            ifields = dict(map(lambda x: (x[0], 'int(fields[' + `x[1]` + '])'), m.items()))
            ffields = dict(map(lambda x: (x[0], 'float(fields[' + `x[1]` + '])'), m.items()))

        # analyze fragments separately
        if "timestamp" in m:
            f_time = ffields["timestamp"]
        elif "ts_sec" in m and "ts_usec" in m:
            f_time = ifields["ts_sec"] + ' + ' + ifields["ts_usec"] + '/1000000.'
        elif "ts_sec" in m:
            f_time = ffields["ts_sec"]
        if self.read_state == "b":
            code += 'dir = ' + ifields["direction"] + '\n'
        else:
            code += 'dir = direction(fields[' + `m["direction"]` + '])\n'
        if "tcp_seq" in m:
            f_seq = ffields["tcp_seq"]
        else:
            f_seq = '0.'
        if "payload_len" in m:
            f_len = ifields["payload_len"]
        else:
            f_len = '0'
        if "tcp_ack" in m:
            code += 'ack = ' + ffields["tcp_ack"] + '\n\
if ack == last_ack[dir]: dup_acks[dir] += 1\n\
else: dup_acks[dir] = 0; last_ack[dir] = ack\n'
            f_ack = 'ack'
            f_dupacks = 'dup_acks[dir]'
        else:
            f_ack = '0.'
            f_dupacks = '0'
        if "tcp_flags" in m:
            if self.read_state == "b":
                code += 'flag = fields[' + `m["tcp_flags"]` + ']\n\
if (flag & 24) == flag: flag = "A"\n\
else: flag = unparse_tcp_flags(flag)\n'
                f_flags = 'flag'
            else:
                f_flags = 'fields[' + `m["tcp_flags"]` + ']'
        else:
            f_flags = '"A"'
        if "tcp_window" in m:
            f_window = ifields["tcp_window"]
        else:
            f_window = '0'

        code += 'self.s[dir].append(Packet(' + f_time + ', ' + f_flags + ', ' + f_seq + ', ' + f_len + ', ' + f_ack + ', ' + f_dupacks + ', ' + f_window + '))\n'

        Connection._parse_code = compile(code, "<generated function>", "exec")
        Connection._parse_code_of = (data, self.read_state)
        Connection._parse_code_min_binary_len = unpack_size + 4
        Connection._parse_code_window = "tcp_window" in m
        self.has_window = Connection._parse_code_window
    
    def _read_nonpacket(self, line):
        if re.match('\\#[pf]?loss', line):
            type, dir, time, seq, end_time, end_seq = line[1:].split()[:6]
            self.loss[direction(dir)].append(LossEvent(type, time, seq, end_time, end_seq))
        elif re.match('!flowid', line):
            fid = line.split()[1:5]
            self.flowid = (fid[0], int(fid[1]), fid[2], int(fid[3]))
        elif re.match('!aggregate', line):
            self.aggregate = int(line.split()[1])
        elif re.match('!data ', line):
            self.read_data = line
            self._check_data()
        elif re.match('!eof$', line):
            return 1
        elif line[:2] == "\037\235" or line[:2] == "\037\213": # compressed data
            raise ConnectionFileCompressedError
        return 0

    def _read_binary(self, f):
        self.read_state = "b"
        self._check_data()

        last_ack = [-1, -1]; dup_acks = [0, 0]
        data = f.read()
        pos, leng = 0, len(data)
        while pos + 4 < leng:
            l, = struct.unpack("!l", data[pos:pos+4])
            i = l & 0x7FFFFFFF
            if pos + i > leng:
                raise ConnectionFormatError, "corrupted file"
            elif l & 0x80000000:
                if self._read_nonpacket(data[pos+4:pos+i]):
                    break
            elif i >= Connection._parse_code_min_binary_len:
                exec Connection._parse_code
            pos += i

    def read(self, f):
        last_ack = [-1, -1]; dup_acks = [0, 0]
        read_state = 0; self.read_state = ""; self.read_data = ""
        f = Connection.Fileboy(f)
        for line in f:
            if line and line[0] >= '0':
                if read_state == 0:
                    read_state = 1; self.read_state = "a"
                    self._check_data()
                exec Connection._parse_code
            elif re.match('!binary', line):
                self.read_state = "b"
                break
            elif self._read_nonpacket(line):
                break
        if self.read_state == "b":
            self._read_binary(f)
        self.available = True
        del self.read_state
        del self.read_data
        self.loss_count = [len(self.loss[0]), len(self.loss[1])]
        return self
    
    def first_index_after(self, time, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            return self.first_index_after(time, 0), self.first_index_after(time, 1)
        else:
            fake_pkt = Packet(time, "A", 0, 0, 0)
            return bisect(self.s[direction(dir)], fake_pkt)
    
    def packets(self, dir, begin=None, end=None, fuzz=0):
        if not self.available:
            self.load()
        dir = direction(dir)
        if begin is None:
            i = 0
        else:
            i = max(self.first_index_after(begin, dir) - fuzz, 0)
        while i < len(self.s[dir]) and (end is None or self.s[dir][i].time <= end):
            yield self.s[dir][i]; i += 1
        while fuzz > 0 and i < len(self.s[dir]):
            yield self.s[dir][i]; i += 1; fuzz -= 1
    
    def rev_packets(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        if end is None:
            i = len(self.s[dir]) - 1
        else:
            i = self.first_index_after(end, dir) - 1
        while i >= 0 and (begin is None or self.s[dir][i].time >= begin):
            yield self.s[dir][i]
            i -= 1
    
    def losses(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        for l in self.loss[dir]:
            if l.time_overlaps(begin, end):
                yield l
    
    def get_time_range(self, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            m0, M0 = self.get_time_range(0)
            m1, M1 = self.get_time_range(1)
            return min(m0, m1), max(M0, M1)
        elif len(self.s[dir]) == 0:
            return 0, 1
        else:
            dir = direction(dir)
            return self.s[dir][0].time, self.s[dir][-1].time
    
    def _time_index(self, dir, time, after):
        if time is not None:
            return self.first_index_after(time, dir)
        elif after:
            return len(self.s[dir])
        else:
            return 0
    
    def _seq_range(self, dir, begin, end):
        s0, s1 = 1e10, 0.
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].seq - 10)
            s1 = max(s1, self.s[dir][i].last_seq + 10)
        for l in self.losses(dir, begin, end):
            s0 = min(s0, l.seq - 10)
            s1 = max(s1, l.end_seq + 10)
        return max(s0, 0.), s1
    
    def _ack_range(self, dir, begin, end):
        s0, s1 = 1e10, 0.
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].ack - 10)
            s1 = max(s1, self.s[dir][i].ack + 10)
        return max(s0, 0.), s1
    
    def get_seq_range(self, dir=None, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        r0, r1 = self._seq_range(dir, begin, end), self._ack_range(1 - dir, begin, end)
        return min(r0[0], r1[0]), max(r0[1], r1[1])
    
    def get_description(self):
        if self.flowid is None:
            self.load()
        s = ""
        if self.aggregate >= 0:
            s += "#" + `self.aggregate` + ": "
        return s + self.flowid[0] + ":" + str(self.flowid[1]) + " > " + self.flowid[2] + ":" + str(self.flowid[3])
    
    def get_flowid_text(self, dir=0):
        if self.flowid is None:
            self.load()
        dirstr = "><"[direction(dir)]
        return self.flowid[0] + ":" + str(self.flowid[1]) + " " + dirstr + " " + self.flowid[2] + ":" + str(self.flowid[3])
    
    def load(self):
        if type(self.filename) != types.StringType:
            raise RuntimeError, "cannot load this Connection " + self.filename
        elif not self.available:
            f = file(self.filename, 'rb')
            try:
                self.read(f)
            except ConnectionFileCompressedError:
                f.seek(0)
                self.read(gzip.GzipFile(fileobj=f))
            f.close()
    
    def unload(self):
        if type(self.filename) == types.StringType:
            self.s = ([], [])
            self.loss = ([], [])
            self.available = False


class FlowRef:

    __slots__ = ['conn', 'dir']

    def __init__(self, conn, dir):
        self.conn, self.dir = conn, dir

    def loss_count(self):
        return self.conn.loss_count[self.dir]

    def aggregate(self):
        return self.conn.aggregate

    def direction(self):
        return self.dir

    def has_window(self):
        return self.conn.has_window

    def get_flowid_text(self):
        return self.conn.get_flowid_text(self.dir)

    def get_description(self):
        s = self.conn.get_description()
        if self.dir:
            s = re.sub(" > ", " < ", s)
        return s
    
    def opposite(self):
        return FlowRef(self.conn, 1 - self.dir)
    
    def unload(self):
        self.conn.unload()

    def __cmp__(self, other):
        if self.conn is other.conn:
            return self.dir - other.dir
        elif self.conn < other.conn:
            return -1
        else:
            return 1

    def __str__(self):
        fid = self.conn.flowid
        return "<#%d: %s:%s %s %s:%s>" % (self.conn.aggregate, fid[0], fid[1], "><"[self.dir], fid[2], fid[3])


class FlowSet:

    SORT_NONE = 0
    SORT_LOSS = 1

    def __init__(self, f=None):
        self.conns = []
        self.flows = []
        self.sorted = FlowSet.SORT_NONE
        if type(f) == types.StringType:
            slash = f.rfind('/')
            if slash >= 0: dir = f[:slash+1]
            else: dir = ''
            self.read(file(f), dir=dir)
        elif f is not None:
            self.read(f)

    def read(self, f, dir=''):
        self.reading_directory = dir
        p = xml.parsers.expat.ParserCreate()
        p.returns_unicode = 0
        p.StartElementHandler = self._start_element
        p.EndElementHandler = self._end_element
        self.reading_state = 0
        self.reading_connection = None
        p.ParseFile(f)

    def _handle_number(self, x, format, precision):
        if precision >= 0 and precision <= 3:
            x = (self >> ((3 - precision) * 8)) & 255
        elif precision >= 4 and precision <= 5:
            x = (self >> ((5 - precision) * 16)) & 65535
        if format == 'n':
            return str(x)
        else:
            return ('%' + format) % x

    def _handle_ip(self, x, precision):
        if precision >= 0 and precision <= 3:
            return x.split('.')[precision]
        else:
            return x

    def _expand_filename(self, aggregate, src, sport, dst, dport):
        s = self.reading_output_pattern
        ss = ''
        pos = s.find('%')
        while pos >= 0:
            ss += s[:pos]; pos += 1
            pad, field_width, precision = ' ', 0, -1
            if s[pos:pos+1] == '0': pad = '0'; pos += 1
            while s[pos:pos+1] >= '0' and s[pos:pos+1] <= '9': field_width = (field_width * 10) + ord(s[pos:pos+1]) - ord('0'); pos += 1
            if s[pos:pos+1] == '.': precision = int(s[pos+1:pos+2]); pos += 2
            x = s[pos:pos+1]
            if x in ['n', 'x', 'X']:
                q = self._handle_number(aggregate, x, precision)
            elif x == 's':
                q = self._handle_ip(src, precision)
            elif x == 'd':
                q = self._handle_ip(dst, precision)
            elif x == 'S':
                q = self._handle_number(sport, 'n', precision)
            elif x == 'D':
                q = self._handle_number(dport, 'n', precision)
            elif x == 'p':
                q = 'T'
            else:
                q = x
            if field_width > len(q): q = (pad * (field_width - len(q))) + q
            ss += q
            s = s[pos+1:]
            pos = s.find('%')
        return self.reading_directory + ss + s

    def _start_element(self, name, attrs):
        if name == 'connections':
            if self.reading_state != 0:
                raise ConnectionFormatError, "nested <connections>"
            self.reading_output_pattern = attrs["filepattern"]
            self.reading_state = 1
        elif name == 'connection' and self.reading_state == 1:
            agg, src, sport, dst, dport = int(attrs["aggregate"]), attrs["src"], int(attrs["sport"]), attrs["dst"], int(attrs["dport"])
            self.reading_connection = Connection(self._expand_filename(agg, src, sport, dst, dport), aggregate=agg, src=src, sport=sport, dst=dst, dport=dport)
            self.conns.append(self.reading_connection)
            self.flows.append(FlowRef(self.reading_connection, 0))
            self.flows.append(FlowRef(self.reading_connection, 1))
        elif name == 'flow' and self.reading_connection is not None:
            try:
                d, l, pl, fl = int(attrs["dir"]), int(attrs["loss"]), int(attrs["ploss"]), int(attrs["floss"])
                self.reading_connection.loss_count[d] += l + pl + fl
            except KeyError:
                pass

    def _end_element(self, name):
        if name == 'connections':
            self.reading_state = 0
        elif name == 'connection':
            self.reading_connection = None

    def sort_by_loss_count(self):
        self.flows.sort(lambda a, b: b.loss_count() - a.loss_count() or a.aggregate() - b.aggregate() or a.dir - b.dir)
        self.sorted = FlowSet.SORT_LOSS

    def __getitem__(self, k):
        if type(k) == types.SliceType:
            return self.flows[k.start:k.stop]
        else:
            return self.flows[k]

    def __len__(self):
        return len(self.flows)

    def append(self, conn):
        conn.load()
        self.conns.append(conn)
        self.flows.append(FlowRef(conn, 0))
        self.flows.append(FlowRef(conn, 1))

    def index(self, flowref):
        if self.sorted == FlowSet.SORT_LOSS:
            l, a = flowref.loss_count(), flowref.aggregate()
            return bisect_with_cmp(self.flows, lambda f: f.loss_count() - l or a - f.aggregate() or flowref.dir - f.dir) - 1
        else:
            return self.flows.index(flowref)


_by_loss_groups = [ (50, "50 or more losses"),
                    (30, "30-49 losses"),
                    (20, "20-29 losses"),
                    (10, "10-19 losses"),
                    (5, "5-9 losses"),
                    (4, "4 losses"),
                    (3, "3 losses"),
                    (2, "2 losses"),
                    (1, "1 loss"),
                    (0, "no losses") ]

class FlowSetTreeModelByLosses(gtk.GenericTreeModel):
    '''This class represents the model of a tree.  The iterators used
    to represent positions are converted to python objects when passed
    to the on_* methods.  This means you can use any python object to
    represent a node in the tree.  The None object represents a NULL
    iterator.'''

    def __init__(self, flowset):
	'''constructor for the model.  Make sure you call
	PyTreeModel.__init__'''
        self.flowset = flowset
        self.analyze_flowset()
	gtk.GenericTreeModel.__init__(self)

    def analyze_flowset(self):
        self.cg = []
        self.gn = []
        if self.flowset is not None and len(self.flowset) > 0:
            self.flowset.sort_by_loss_count()
            i = 0; first = 0; lc = self.flowset[i].loss_count()
            blg = 0; min_losses = _by_loss_groups[blg][0]
            while i < len(self.flowset):
                f = self.flowset[i]
                if f.loss_count() < min_losses:
                    if first < i:
                        self.gn.append(_by_loss_groups[blg][1])
                        self.cg.append(self.flowset[first:i])
                        first = i
                    blg += 1; min_losses = _by_loss_groups[blg][0]
                else:
                    i += 1
            if first < i:
                self.gn.append(_by_loss_groups[blg][1])
                self.cg.append(self.flowset[first:i])

    # the implementations for TreeModel methods are prefixed with on_
    def on_get_flags(self):
	'''returns the GtkTreeModelFlags for this particular type of model'''
	return 0
    def on_get_n_columns(self):
	'''returns the number of columns in the model'''
	return 3
    def on_get_column_type(self, index):
	'''returns the type of a column in the model'''
	return gobject.TYPE_STRING
    
    def on_get_path(self, node):
	'''returns the tree path (a tuple of indices at the various
	levels) for a particular node.'''
        return node
    def on_get_iter(self, path):
        '''returns the node corresponding to the given path.  In our
        case, the node is the path'''
        return path

    def path2flowref(self, n):
        assert len(n) == 2
        return self.cg[n[0]][n[1]]
    def flowref2path(self, fref):
        lc = fref.loss_count()
        i = 0
        while i < len(self.cg) and lc < self.cg[i][-1].loss_count():
            i += 1
        if i >= len(self.cg):
            return None
        for j in range(0, len(self.cg[i])):
            if self.cg[i][j] == fref:
                return (i, j)
        return None
    
    def on_get_value(self, n, column):
	'''returns the value stored in a particular column for the node'''
        if len(n) == 1:
            if column == 1:
                return self.gn[n[0]]
            else:
                return ''
        elif column == 0:
            # XXX shown()
            return ''
        elif column == 1:
            l = self.path2flowref(n).loss_count()
            if l == 1:
                return '1 loss'
            else:
                return `l` + ' losses'
        elif column == 2:
            return '#' + `self.path2flowref(n).aggregate()`
        else:
            return self.path2flowref(n).get_flowid_text()
            
    def on_iter_next(self, n):
	'''returns the next node at this level of the tree'''
        if len(n) == 1 and n[0] < len(self.cg) - 1:
            return n[0]+1,
        elif len(n) == 2 and n[1] < len(self.cg[n[0]]) - 1:
            return n[0], n[1]+1
        else:
            return None
    def on_iter_children(self, n):
	'''returns the first child of this node'''
        if n is None:
            if len(self.cg) > 0:
                return 0,
        elif len(n) == 1:
            return n + (0,)
        return None
    def on_iter_has_child(self, n):
	'''returns true if this node has children'''
        if n is None:
            return len(self.cg) > 0
        else:
            return len(n) == 1
    def on_iter_n_children(self, n):
	'''returns the number of children of this node'''
        if n is None:
            return len(self.cg)
        elif len(n) == 1:
            return len(self.cg[n[0]])
        else:
            return 0
    def on_iter_nth_child(self, n, i):
	'''returns the nth child of this node'''
        if n is None:
            return i,
        elif len(n) == 1 and i < len(self.cg[n[0]]):
            return n + (i,)
        else:
            return None
    def on_iter_parent(self, n):
	'''returns the parent of this node'''
	if len(n) == 0:
	    return None
	else:
	    return n[:-1]



def fix_range(a, b, min_step_frac):
    d = b - a
    step = 10 ** floor(log10(d))

    # make step bigger if required
    if step / d > 0.5 and step / d >= min_step_frac:
        if step/5 / d >= min_step_frac:
            step /= 5
        elif step/2.5 / d >= min_step_frac:
            step /= 2.5
        elif step/2 / d >= min_step_frac:
            step /= 2
    while step < d and step / d < min_step_frac:
        if 2*step / d >= min_step_frac:
            step *= 2
        elif 2.5*step / d >= min_step_frac:
            step *= 2.5
        elif 5*step / d >= min_step_frac:
            step *= 5
        else:
            step *= 10
    if step >= d:
        step = d

    # bound a and b to multiples of step, if appropriate
    a_try = floor(a / step) * step
    if a - a_try < 0.1*d:
        a = a_try; d = b - a
    b_try = ceil(b / step) * step
    if b_try - b < 0.1*d:
        b = b_try
    
    # return a dictionary
    return { "low": a, "high": b, "step": step }


class PlotCursors:

    _d = {
    "zoomin": ("zoomin_data", "zoom_mask", 6, 6, gtk.gdk.SB_UP_ARROW),
    "zoomout": ("zoomout_data", "zoom_mask", 6, 6, gtk.gdk.SB_DOWN_ARROW),
    "hand": ("hand_data", "hand_mask", 9, 8, gtk.gdk.FLEUR),
    "grabhand": ("grabhand_data", "grabhand_mask", 8, 7, gtk.gdk.FLEUR),
    "zoomin_data": (string.join(map(chr, [
	0xf0, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x04, 0x00, 0x62, 0x04, 0x00,
        0x61, 0x08, 0x00, 0xf9, 0x09, 0x00, 0xf9, 0x09, 0x00, 0x61, 0x08, 0x00,
        0x62, 0x04, 0x00, 0x02, 0x04, 0x00, 0x0c, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00 ]), ''), 17, 17),
    "zoomout_data": (string.join(map(chr, [
	0xf0, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x04, 0x00, 0x02, 0x04, 0x00,
        0x01, 0x08, 0x00, 0xf9, 0x09, 0x00, 0xf9, 0x09, 0x00, 0x01, 0x08, 0x00,
        0x02, 0x04, 0x00, 0x02, 0x04, 0x00, 0x0c, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00 ]), ''), 17, 17),
    "zoom_mask": (string.join(map(chr, [
        0xf0, 0x00, 0x00, 0xfc, 0x03, 0x00, 0xfe, 0x07, 0x00, 0xfe, 0x07, 0x00,
        0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00,
        0xfe, 0x07, 0x00, 0xfe, 0x07, 0x00, 0xfc, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00]), ''), 17, 17),
    "hand_data": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x1c, 0x00, 0xc8, 0x24, 0x00,
        0xc8, 0xa4, 0x00, 0x90, 0x64, 0x01, 0x90, 0x24, 0x01, 0x2c, 0x20, 0x01,
        0x32, 0x00, 0x01, 0x22, 0x80, 0x00, 0x04, 0x80, 0x00, 0x08, 0x80, 0x00,
        0x08, 0x40, 0x00, 0x10, 0x40, 0x00, 0x20, 0x20, 0x00, 0x40, 0x20, 0x00,
        0x40, 0x20, 0x00, 0x00, 0x00, 0x00]), ''), 18, 18),
    "hand_mask": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x1f, 0x00, 0xf8, 0x3f, 0x00,
        0xf8, 0xbf, 0x00, 0xf0, 0xff, 0x01, 0xf0, 0xff, 0x01, 0xec, 0xff, 0x01,
        0xfe, 0xff, 0x01, 0xfe, 0xff, 0x00, 0xfc, 0xff, 0x00, 0xf8, 0xff, 0x00,
        0xf8, 0x7f, 0x00, 0xf0, 0x7f, 0x00, 0xe0, 0x3f, 0x00, 0xc0, 0x3f, 0x00,
        0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00]), ''), 18, 18),
    "grabhand_data": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0d, 0x48, 0x12,
        0x08, 0x30, 0x0c, 0x40, 0x0a, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x20,
        0x04, 0x20, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10]), ''), 16, 16),
    "grabhand_mask": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0d, 0xf8, 0x1f,
        0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x3f,
        0xfc, 0x3f, 0xf8, 0x1f, 0xf0, 0x1f, 0xf0, 0x1f]), ''), 16, 16)
    }

    def __init__(self, win):
        self.window = win
    def make_pixmap(self, name):
        pname = name + ".pix"
        if pname not in PlotCursors._d:
            try:
                l = PlotCursors._d[name]
                PlotCursors._d[pname] = gtk.gdk.bitmap_create_from_data(self.window.window, l[0], l[1], l[2])
            except:
                PlotCursors._d[pname] = None
        return PlotCursors._d[pname]
    def __getitem__(self, name):
        cname = name + ".cur"
        if cname not in PlotCursors._d:
            if name not in PlotCursors._d:
                PlotCursors._d[name] = ("", "", 0, 0, gtk.gdk.LEFT_PTR)
            data, mask, hotx, hoty, default = PlotCursors._d[name]
            dpix, mpix = self.make_pixmap(data), self.make_pixmap(mask)
            if dpix is not None and mpix is not None:
                black = self.window.get_style().black
                white = self.window.get_style().white
                PlotCursors._d[cname] = gtk.gdk.Cursor(dpix, mpix, black, white, hotx, hoty)
            else:
                PlotCursors._d[cname] = gtk.gdk.Cursor(default)
        return PlotCursors._d[cname]


ANCHOR_N = 0
ANCHOR_E = 1

class PlotCanvas_ScreenDrawable:

    _gcs = { }

    def __init__(self, plotcanvas, immediate=False):
        self.plotcanvas = plotcanvas
        self.playout = None
        self.small_playout = None
        if immediate: self.drawable = plotcanvas.canvas.window

    def gc(self, name):
        if name in PlotCanvas_ScreenDrawable._gcs:
            return PlotCanvas_ScreenDrawable._gcs[name]
        orig_name = name
        if name not in _screen_style:
            name = re.sub("\\..*", "", name)
        s = _screen_style[name]
        cmap = self.plotcanvas.canvas.get_colormap()
        gc = self.plotcanvas.canvas.window.new_gc(foreground=cmap.alloc_color(red=s.red * 65535, green=s.green * 65535, blue=s.blue * 65535), line_width=0, cap_style=gtk.gdk.CAP_BUTT)
        if s.linewidth != 1:
            gc.line_width = s.linewidth
        if len(s.dash) > 0:
            gc.set_dashes(0, s.dash)
        PlotCanvas_ScreenDrawable._gcs[orig_name] = gc
        return gc

    def layout(self, name=""):
        if name == "small":
            if self.small_playout is None:
                new_pcontext = self.plotcanvas.canvas.create_pango_context()
                new_pfontdesc = new_pcontext.get_font_description().copy()
                new_pfontdesc.set_size(new_pfontdesc.get_size() * 0.75)
                new_pcontext.set_font_description(new_pfontdesc)
                self.small_playout = pango.Layout(new_pcontext)
            return self.small_playout
        elif name == "":
            if self.playout is None:
                self.playout = self.plotcanvas.canvas.create_pango_layout("")
            return self.playout
        else:
            raise RuntimeError("bad layout name " + name)

    def prepare(self):
        self.drawable = self.plotcanvas.backing_store

    def plot_bounds(self):              # returns (left_margin, top_margin, width, height)
        p = self.plotcanvas
        return (p.left_margin, p.top_margin, p.plot_width, p.plot_height)

    def complete(self):
        gc = self.plotcanvas.canvas.get_style().black_gc
        self.plotcanvas.canvas.window.draw_drawable(gc, self.drawable, 0, 0, 0, 0, -1, -1)
        self.plotcanvas.backing_store_updated = True
    
    def clip(self, gc, rectangle):
        gc.set_clip_rectangle(rectangle)

    def unclip(self, gc):
        pass

    def clear(self):
        gc = self.plotcanvas.canvas.get_style().bg_gc[gtk.STATE_NORMAL]
        self.drawable.draw_rectangle(gc, True, 0, 0, -1, -1)
    
    def draw_line(self, gc, x1, y1, x2, y2):
        self.drawable.draw_line(gc, x1, y1, x2, y2)

    def draw_lines(self, gc, l):
        if len(l) > 1 and l[0][0] < 0:
            x1, y1 = l[0]; x2, y2 = l[1]
            l[0] = (0, y1 + (-x1 / (x2 - x1)) * (y2 - y1))
        if len(l) > 1:
            self.drawable.draw_lines(gc, l)

    def fill_rectangle(self, gc, *args):
        if len(args) == 1 and len(args[0]) == 4:
            area = args[0]
            self.drawable.draw_rectangle(gc, True, area[0], area[1], area[2], area[3])
        elif len(args) == 4:
            self.drawable.draw_rectangle(gc, True, args[0], args[1], args[2], args[3])
        else:
            raise TypeError("PlotCanvas_Drawable.fill_rectangle() takes 1 or 4 arguments")

    def draw_rectangle(self, gc, x1, y1, w, h):
        self.drawable.draw_rectangle(gc, gtk.FALSE, x1, y1, w, h)

    def draw_text(self, gc, layout, text, x, y, anchor=ANCHOR_N):
        layout.set_text(text, -1)
        ir, lr = layout.get_extents()
        if anchor == ANCHOR_N:
            self.drawable.draw_layout(gc, x - lr[2]/2048.0, y + 2, layout)
        elif anchor == ANCHOR_E:
            self.drawable.draw_layout(gc, x - 4 - lr[2]/1024.0, y - lr[3]/2048.0, layout)
        else:
            raise RuntimeError("bad anchor " + str(anchor))

    def text_extents(self, layout, text, x, y, anchor=ANCHOR_N):
        layout.set_text(text, -1)
        ir, lr = layout.get_extents()
        if anchor == ANCHOR_N:
            return (x - lr[2]/2048.0, y + 2, lr[2]/1024.0, lr[3]/1024.0)
        elif anchor == ANCHOR_E:
            return (x - 4 - lr[2]/1024.0, y - lr[3]/2048.0, lr[2]/1024.0, lr[3]/1024.0)
        else:
            raise RuntimeError("bad anchor " + str(anchor))

    def draw_data(self, gc, x, y1, y2):
        self.draw_line(gc, x - 2, y1, x + 2, y1)
        self.draw_line(gc, x - 2, y2, x + 2, y2)
        self.draw_line(gc, x, y1, x, y2)

    def draw_ack(self, gc, x, y):
        self.draw_line(gc, x - 2, y - 2, x + 3, y + 3)
        self.draw_line(gc, x - 2, y + 2, x + 3, y - 3)
    
    def draw_dataack(self, gc, x, y):
        self.draw_line(gc, x - 2, y - 2, x + 3, y + 3)
        self.draw_line(gc, x - 2, y + 2, x + 3, y - 3)
        self.draw_line(gc, x - 2, y, x + 2, y)
        self.draw_line(gc, x, y + 2, x, y - 2)


class Helvetica:
    WIDTHS = { '0': 0.556, '1': 0.556, '2': 0.556, '3': 0.556, '4': 0.556,
               '5': 0.556, '6': 0.556, '7': 0.556, '8': 0.556, '9': 0.556,
               'K': 0.667, '.': 0.278, '+': 0.584, '-': 0.584 }

    def __init__(self, size):
        self.size = size

    def write_define(f):
        f.write("/Helvetica findfont dup length dict begin {\n\
  1 index /FID ne {def} {pop pop} ifelse\n\
} forall\n\
/Encoding[StandardEncoding aload pop]dup 45/minus put def\n\
currentdict end /Helvetica.tcpplot exch definefont pop\n")
    write_define = staticmethod(write_define)

    def write_select(self, f):
        f.write('/Helvetica.tcpplot ' + str(self.size) + ' selectfont\n')

    def height(self):
        return 0.718 * self.size
        
    def extents(self, str):
        w = reduce(lambda x, y: x + self.WIDTHS[y], str, 0)
        if w == 0:
            return (0, 0, 0, 0)
        else:
            return (0, 0, w * self.size, self.height())


class PlotCanvas_PostScriptDrawable:

    FONT = Helvetica

    def __init__(self, plotcanvas, f):
        self.plotcanvas = plotcanvas
        self.f = f
        self.cur_font = None
        self.cur_gc = None

    def gc(self, name):
        return name

    def layout(self, name=""):
        if name == "small":
            return self.FONT(8)
        elif name == "":
            return self.FONT(12)
        else:
            raise RuntimeError("bad layout name " + name)

    def prepare(self):
        self.f.write("%!PS-Adobe-3.0\n")
        self.FONT.write_define(self.f)
        self.f.write("/m/moveto load def/l{lineto stroke}bind def/L/lineto load def/rf/rectfill load def/rd/rectstroke load def/s/show load def\n")
        for key in _postscript_style:
            s = _postscript_style[key]
            self.f.write("/GC" + key + "{" + str(s.red) + " " + str(s.green) + " " + str(s.blue) + " setrgbcolor " + str(s.linewidth) + " setlinewidth")
            if len(s.dash):
                self.f.write("[" + reduce(lambda x, y: str(x) + " " + str(y), s.dash) + "]0 setdash ")
            else:
                self.f.write("[]0 setdash ")
            self.f.write("}bind def\n")
        self.f.write("/Pd{moveto -2 0 rmoveto 4 0 rlineto 0 1 index rmoveto -4 0 rlineto 2 0 rmoveto 0 exch neg rlineto stroke}bind def\n\
/Pa{moveto -2 -2 rmoveto 4 4 rlineto 0 -4 rmoveto -4 4 rlineto stroke}bind def\n\
/Pda{moveto -2 -2 rmoveto 4 4 rlineto 0 -4 rmoveto -4 4 rlineto 0 -2 rmoveto 4 0 rlineto -2 -2 rmoveto 0 4 rlineto stroke}bind def\n\
90 rotate 0 -612 translate\n")
        self.cur_gc = None
        self.top = 612

    def plot_bounds(self):              # returns (left_margin, top_margin, width, height)
        return (72, 72, 684, 504)
    
    def complete(self):
        self.f.write("showpage\n")
        
    def clip(self, gc, rectangle):
        x, y, w, h = rectangle
        self.f.write("gsave " + str(x) + ' ' + str(self.top - y - h) + ' ' + str(w) + ' ' + str(h) + " rectclip\n")

    def unclip(self, gc):
        self.f.write("grestore\n")

    def clear(self):
        pass

    def select_gc(self, gc):
        self.f.write("GC" + gc + "\n")
        self.cur_gc = gc
    
    def select_font(self, font):
        font.write_select(self.f)
        self.cur_font = font
    
    def draw_line(self, gc, x1, y1, x2, y2):
        if self.cur_gc is not gc: self.select_gc(gc)
        self.f.write(str(x1) + " " + str(self.top - y1) + " m " + str(x2) + " " + str(self.top - y2) + " l\n")

    def draw_lines(self, gc, l):
        if len(l) > 1:
            if self.cur_gc is not gc: self.select_gc(gc)
            s = " m\n"
            for p in l:
                self.f.write(str(p[0]) + " " + str(self.top - p[1]) + s)
                s = " L\n"
            self.f.write("stroke\n")

    def fill_rectangle(self, gc, x, y, w, h):
        if self.cur_gc is not gc: self.select_gc(gc)
        self.f.write(str(x) + " " + str(self.top - y - h) + " " + str(w) + " " + str(h) + " rf\n")

    def draw_rectangle(self, gc, x1, y1, w, h):
        if self.cur_gc is not gc: self.select_gc(gc)
        self.f.write(str(x1) + " " + str(self.top - y1 - h) + " " + str(w) + " " + str(h) + " rd\n")

    def draw_text(self, gc, font, text, x, y, anchor=ANCHOR_N):
        if self.cur_font is not font: self.select_font(font)
        if self.cur_gc is not gc: self.select_gc(gc)
        lr = font.extents(text)
        if anchor == ANCHOR_N:
            self.f.write(str(x - lr[2]/2.0) + " " + str(self.top - y - lr[3] - 4) + " m(" + text + ")s\n")
        elif anchor == ANCHOR_E:
            self.f.write(str(x - 4 - lr[2]) + " " + str(self.top - y - lr[3]/2.0) + " m(" + text + ")s\n")
        else:
            raise RuntimeError("bad anchor " + str(anchor))

    def text_extents(self, font, text, x, y, anchor=ANCHOR_N):
        lr = font.extents(text)
        if anchor == ANCHOR_N:
            return (x - lr[2]/2.0, y + 2, lr[2], lr[3])
        elif anchor == ANCHOR_E:
            return (x - 4 - lr[2], y - lr[3]/2.0, lr[2], lr[3])
        else:
            raise RuntimeError("bad anchor " + str(anchor))

    def draw_data(self, gc, x, y1, y2):
        if self.cur_gc is not gc: self.select_gc(gc)
        self.f.write(str(y2 - y1) + " " + str(x) + " " + str(self.top - y1) + " Pd\n")

    def draw_ack(self, gc, x, y):
        if self.cur_gc is not gc: self.select_gc(gc)
        self.f.write(str(x) + " " + str(self.top - y) + " Pa\n")
    
    def draw_dataack(self, gc, x, y):
        if self.cur_gc is not gc: self.select_gc(gc)
        self.f.write(str(x) + " " + str(self.top - y) + " Pda\n")


class PlotCanvas:

    TOOL_NONE = 0
    TOOL_HAND = 1
    TOOL_ZOOM_IN = 2
    TOOL_ZOOM_OUT = 3
    TOOL_GRABHAND = 4
    TOOL_IDENTIFY = 5
    _tool_cursor = ("", "hand", "zoomin", "zoomout", "grabhand", "")

    DRAG_STICKINESS = 5
    IDENTIFY_MAGNETISM = 24
    DRAG_MAGNETISM = 12
    
    # initialization
    def __init__(self, master, width=600, height=500):
        self.canvas = gtk.DrawingArea()
        self.canvas.set_size_request(width, height)
        self.canvas.set_double_buffered(False) # we do our own
        self.canvas.set_flags(gtk.CAN_FOCUS)

        self.canvas.connect("configure_event", self.cmd_configure)
        self.canvas.connect("expose_event", self.cmd_expose)
        self.canvas.connect("button_press_event", self.cmd_press)
        self.canvas.connect("motion_notify_event", self.cmd_motion)
        self.canvas.connect("button_release_event", self.cmd_release)
        self.canvas.connect("key_press_event", self.cmd_check_state_focus)
        self.canvas.connect("key_release_event", self.cmd_check_state_focus)
        self.canvas.connect("enter_notify_event", self.cmd_check_state)
        self.canvas.set_events(gtk.gdk.EXPOSURE_MASK | gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK | gtk.gdk.ENTER_NOTIFY_MASK | gtk.gdk.LEAVE_NOTIFY_MASK | gtk.gdk.KEY_PRESS_MASK | gtk.gdk.KEY_RELEASE_MASK | gtk.gdk.POINTER_MOTION_MASK | gtk.gdk.POINTER_MOTION_HINT_MASK)
        
        master.pack_start(self.canvas, expand=1, fill=1)
        self.canvas.show()

        self.left_margin = 40
        self.right_margin = 20
        self.top_margin = 10
        self.bottom_margin = 20
        self.plotted = False
        self.press = None
        self.press_state = 0
        self.tool = PlotCanvas.TOOL_IDENTIFY
        self.show_tool = PlotCanvas.TOOL_NONE
        self.begin = 0
        self.end = 1000000000.0
        self.show_window = True
        self.backing_store = None
        self.backing_store_updated = False

        self.highlight = [None]
        self.highlight_bounds = None
        self.highlight_hooks = []
        
        self.adjustment = gtk.Adjustment()
        self.adjustment.connect("value_changed", self.adj_value_changed)
        self.adjusting = False

    # getting properties
    def get_direction(self):
        return self.dir
    def get_flowref(self):
        return FlowRef(self.conn, self.dir)
    def get_plotted_time_range(self):
        if self.plotted:
            return (self.left_margin - self.toff) / self.tscale, (self.left_margin + self.plot_width - self.toff) / self.tscale
        else:
            return self.begin, self.end
    def get_time_adjustment(self):
        return self.adjustment
    def get_show_window(self):
        return self.show_window

    # setting properties
    def set_flowref(self, fref, keeptime=False):
        self.conn, self.dir = fref.conn, fref.dir
        self.highlight = [None]
        if keeptime:
            self.plot()
        else:
            self.view_all()
    def set_show_window(self, show_window):
        self.show_window = show_window
        if self.plotted: self.plot()
    def view_all(self):
        self.set_time_range(None, interval=1000000000.0)
    def set_time_range(self, begin, interval=None, incr=False):
        true_begin = max(self.conn.get_time_range()[0] - 0.001, 0)
        true_end = self.conn.get_time_range()[1]
        
        if begin is None: begin = true_begin
        if interval is None: interval = self.end - self.begin

        old_begin, old_end = self.begin, self.end
        self.end = min(max(begin, 0) + interval, true_end)
        self.begin = max(min(begin, self.end - interval), 0)
        if incr and self.begin == old_begin and self.end == old_end: return

        self.highlight = [None]
        if self.plotted: self.plot()

        # now, emit changed values onto the adjustment
        begin, end = self.get_plotted_time_range()
        self.adjusting = True
        a = self.adjustment
        a.lower = float(true_begin)
        a.upper = float(max(end, true_end))
        a.page_size = float(end - self.begin)
        a.page_increment = a.page_size * 0.7
        a.step_increment = a.page_size * 0.03
        a.emit("changed")
        a.set_value(self.begin)
        self.adjusting = False
    def adj_value_changed(self, adj):
        if not self.adjusting:
            self.set_time_range(adj.value)
        
    def zoom(self, when=None, factor=1):
        if when is None: when = (self.begin + self.end) / 2
        new_dt = (self.end - self.begin) * factor
        t0, t1 = self.get_plotted_time_range()
        new_t0 = max(when - new_dt * ((when - t0) / (t1 - t0)), 0)
        self.set_time_range(new_t0, new_dt, incr=True)

    def grab_focus(self):
        self.canvas.grab_focus()

    # selecting tools
    def select_tool(self, which):
        self.tool = which
        self._check_tool(self.canvas.window.get_pointer()[2])

    def cmd_configure(self, widget, event):
        x, y, self.wwidth, self.wheight = widget.get_allocation()
        self.backing_store = gtk.gdk.Pixmap(widget.window, self.wwidth, self.wheight)
        self.backing_store_updated = False

        # xxx
        self.canvas.window.set_cursor(PlotCursors(self.canvas)["hand"])
        
        self.plot_width = self.wwidth - self.left_margin - self.right_margin
        self.plot_height = self.wheight - self.top_margin - self.bottom_margin
    def cmd_expose(self, widget, event):
        if not self.backing_store_updated:
            self.plot()
        else:
            self.expose_rectangle(event.area)
        if self.highlight[0] is not None:
            self.draw_highlight()
    def expose_rectangle(self, area):
        x, y, w, h = area
        if not self.backing_store_updated:
            self.plot()
        elif w > 0 and h > 0:
            gc = self.canvas.get_style().black_gc
            self.canvas.window.draw_drawable(gc, self.backing_store, x, y, x, y, w, h)

    # Transformation
    def _itransform(self, x, y, constrain=True):
        if self.plotted and (not constrain or (x >= self.left_margin and x <= self.left_margin + self.plot_width and y >= self.top_margin and y <= self.top_margin + self.plot_height)):
            return (x - self.toff) / self.tscale, (y - self.soff) / self.sscale
        else:
            raise ValueError
    def _transform(self, xx, yy, yy2=None):
        if not self.plotted:
            raise ValueError
        elif yy2 is None:
            return xx * self.tscale + self.toff, yy * self.sscale + self.soff
        else:
            return xx * self.tscale + self.toff, yy * self.sscale + self.soff, yy2 * self.sscale + self.soff
    def _transform_packet(self, p, dir):
        if dir == self.dir:
            return self._transform(p.time, p.seq)
        else:
            return self._transform(p.time, p.ack)
    
    def cmd_press(self, widget, event):
        if event.button == 1:
            try:
                if self.show_tool == PlotCanvas.TOOL_IDENTIFY and self.highlight[0] == "packet":
                    self.press = self._transform_packet(self.highlight[1], self.highlight[2])
                else:
                    self._itransform(event.x, event.y) # for signal
                    self.press = (event.x, event.y)
                if self.tool == PlotCanvas.TOOL_IDENTIFY:
                    self.set_highlight(["bandwidth", 0, event.x, event.y, self.highlight])
            except ValueError:
                self.press = None
            self.stuck = True
            self.press_state = event.state | gtk.gdk.BUTTON1_MASK
            self._check_tool(self.press_state)
        self.grab_focus()
        return 1
    def cmd_motion(self, widget, event):
        x, y, state = widget.window.get_pointer()
        try:
            if self.show_tool == PlotCanvas.TOOL_GRABHAND and self.plotted and self.press is not None:
                if self.stuck and (abs(self.press[0] - x) > PlotCanvas.DRAG_STICKINESS):
                    self.stuck = False
                    self.drag_t0 = self.get_plotted_time_range()[0]
                    self.drag_tscale = self.tscale
                if not self.stuck:
                    shift_x = (x - self.press[0]) / self.drag_tscale
                    self.set_time_range(self.drag_t0 - shift_x)
            elif self.tool == PlotCanvas.TOOL_IDENTIFY:
                if (state & gtk.gdk.BUTTON1_MASK) and self.press is not None and self.show_tool == PlotCanvas.TOOL_IDENTIFY:
                    cp = self.closest_packet(x, y, mindist=PlotCanvas.DRAG_MAGNETISM)
                    if cp is not None: x, y = self._transform_packet(cp[1], cp[2])
                    t, s = self._itransform(x, y, constrain=False)
                    tt, ss = self._itransform(self.press[0], self.press[1])
                    h = ["bandwidth", 0, x, y, self.highlight[4]]
                    if cp is not None: h.append(cp)
                    if t != tt: h[1] = (s - ss) / (t - tt)
                    self.set_highlight(h)
                else:
                    self.set_highlight(self.closest_packet(x, y))
        except ValueError:
            pass
        return 1
    def cmd_release(self, widget, event):
        try:
            if event.button != 1 or self.press is None:
                pass
            elif self.show_tool == PlotCanvas.TOOL_ZOOM_OUT:
                when = self._itransform(event.x, event.y)[0]
                self.zoom(when, 4)
            elif self.show_tool == PlotCanvas.TOOL_ZOOM_IN:
                when = self._itransform(event.x, event.y)[0]
                self.zoom(when, 0.25)
            elif self.show_tool == PlotCanvas.TOOL_IDENTIFY:
                self.set_highlight(None)
        except ValueError:
            pass
        self._check_tool(self.canvas.window.get_pointer()[2])
        self.press = None
        return 1
    def _check_tool(self, state):
        t = self.tool
        if t == PlotCanvas.TOOL_HAND or t == PlotCanvas.TOOL_IDENTIFY:
            if state & gtk.gdk.BUTTON1_MASK:
                state = self.press_state
            if state & gtk.gdk.MOD1_MASK:
                t = PlotCanvas.TOOL_ZOOM_OUT
            elif state & gtk.gdk.CONTROL_MASK:
                t = PlotCanvas.TOOL_ZOOM_IN
        if t == PlotCanvas.TOOL_HAND and state & gtk.gdk.BUTTON1_MASK:
            t = PlotCanvas.TOOL_GRABHAND
        if t != self.show_tool:
            self.show_tool = t
            self.canvas.window.set_cursor(PlotCursors(self.canvas)[PlotCanvas._tool_cursor[t]])
    def cmd_check_state(self, widget, event):
        self._check_tool(widget.window.get_pointer()[2])
        return 1
    def cmd_check_state_focus(self, widget, event):
        self._check_tool(widget.window.get_pointer()[2])
        self.grab_focus()
        return 1

    # IDENTIFY tool
    def closest_packet(self, x0, y0, mindist=IDENTIFY_MAGNETISM):
        try:
            t0, t1 = self.get_plotted_time_range()
            t = self._itransform(x0, y0, constrain=False)[0]
            delta = mindist / self.tscale
            found = None; best_dist = mindist ** 2
            tscale, toff, sscale, soff = self.tscale, self.toff, self.sscale, self.soff
            for p in self.conn.packets(self.dir, max(t - delta, t0), min(t + delta, t1)):
                x, y1, y2 = p.time * tscale + toff, p.seq * sscale + soff, p.last_seq * sscale + soff
                dist = (x - x0) ** 2
                if y0 > y1: dist += (y0 - y1) ** 2
                elif y0 < y2: dist += (y0 - y2) ** 2
                if dist < best_dist:
                    found = ('packet', p, self.dir); best_dist = dist
            for p in self.conn.packets(1 - self.dir, max(t - delta, t0), min(t + delta, t1)):
                x, y = p.time * tscale + toff, p.ack * sscale + soff
                dist = (x - x0) ** 2 + (y - y0) ** 2
                if dist < best_dist:
                    found = ('packet', p, 1 - self.dir); best_dist = dist
            return found
        except ValueError:
            return None

    # drawing helpers
    def _draw_label_y(self, text, pos, edge1, edge2, drawable, gc, layout):
        if re.match(".*e\\+0[4-7]$", text):
            text = str(float(text))[:-2]
        if re.match("...*000$", text):
            text = text[:-3] + "K"
        drawable.draw_text(gc, layout, text, edge1, pos, anchor=ANCHOR_E)
    def _draw_label_x(self, text, pos, edge1, edge2, drawable, gc, layout):
        drawable.draw_text(gc, layout, text, pos, edge2, anchor=ANCHOR_N)
    def _draw_tic_x(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, pos, edge1, pos, edge1 + len)
        drawable.draw_line(gc, pos, edge2, pos, edge2 - len)
    def _draw_tic_y(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, edge1, pos, edge1 + len, pos)
        drawable.draw_line(gc, edge2, pos, edge2 - len, pos)
    def _draw_axis(self, scale, off, pos1, pos2, step, edge1, edge2, ticer, labeller, drawable, gc_tic, gc_label, playout):
        if abs(step * scale) >= 75:
            mstep = step / 10
        else:
            mstep = step / 4
        for pos in frange(floor(pos1 / step) * step, pos2, step):
            pix = pos * scale + off
            if pos >= pos1:
                ticer(pix, edge1, edge2, 5, drawable, gc_tic)
                labeller("%g" % pos, pix, edge1, edge2, drawable, gc_label, playout)
            for mpos in frange(pos + mstep, min(pos + step, pos2), mstep):
                mpix = mpos * scale + off
                if mpos >= pos1:
                    ticer(mpix, edge1, edge2, 2, drawable, gc_tic)

    def plot(self, drawable=None):
        if drawable is None: drawable = PlotCanvas_ScreenDrawable(self)
        drawable.prepare()
        drawable.clear()
        if self.conn is not None:

            # analyze time ranges
            ranges = fix_range(self.begin, self.end, 30.0 / self.plot_width)
            t0, t1, tstep = ranges["low"], ranges["high"], ranges["step"]

            # analyze sequence ranges
            s0, s1 = self.conn.get_seq_range(self.dir, t0, t1)
            if s1 <= s0: s0 = 0; s1 = 1
            ranges = fix_range(s0, s1, 30.0 / self.plot_height)
            s0, s1, sstep = ranges["low"], ranges["high"], ranges["step"]

            # get transformation
            left_margin, top_margin, plot_width, plot_height = drawable.plot_bounds()
            tscale = plot_width / float(t1 - t0)
            sscale = plot_height / float(s0 - s1)
            toff = left_margin - (t0 * tscale)
            soff = top_margin - (s1 * sscale)
            self.tscale, self.sscale, self.toff, self.soff = tscale, sscale, toff, soff

            # mark that self.tscale, self.sscale, etc. are available
            self.plotted = True
            
            # variables
            playout = drawable.layout()
            small_playout = drawable.layout("small")

            # clear background
            drawable.fill_rectangle(drawable.gc("bg"), left_margin, top_margin, plot_width, plot_height)

            # losses
            gc = drawable.gc("lossborder")
            for l in self.conn.losses(self.dir, t0, t1):
                x0 = max(t0, l.begin) * tscale + toff
                x1 = min(t1, l.end) * tscale + toff
                y0 = max(s0, l.seq) * sscale + soff
                y1 = min(s1, l.end_seq) * sscale + soff
                gc_fg, gc_bg = drawable.gc(l.type), drawable.gc(l.type + ".bg")
                drawable.fill_rectangle(gc_bg, x0, top_margin, x1 - x0 + 1, plot_height)
                drawable.fill_rectangle(gc_fg, x0, y1, x1 - x0 + 1, y0 - y1 + 1)
                drawable.draw_rectangle(gc, x0, y1, x1 - x0 + 1, y0 - y1 + 1)
            
            # border box
            border_gc = drawable.gc("border")
            drawable.draw_rectangle(border_gc, left_margin, top_margin, plot_width, plot_height)

            # axes
            label_gc = drawable.gc("label")
            self._draw_axis(tscale, toff, t0, t1, tstep, top_margin, top_margin + plot_height, self._draw_tic_x, self._draw_label_x, drawable, border_gc, label_gc, playout)
            self._draw_axis(sscale, soff, s0, s1, sstep, left_margin, left_margin + plot_width, self._draw_tic_y, self._draw_label_y, drawable, border_gc, label_gc, playout)

            # ack packets
            gc1, gc2 = drawable.gc("ack"), drawable.gc("dataack")
            last_dupack, last_dupack_x = -1, None
            for p in self.conn.rev_packets(1 - self.dir, t0, t1):
                x, y = int(floor(p.time * tscale + toff)), int(floor(p.ack * sscale + soff))
                if p.dup_acks > 0 and (p.ack != last_dupack or x < last_dupack_x):
                    text = str(p.dup_acks + 1)
                    extents = drawable.text_extents(small_playout, text, x, y, anchor=ANCHOR_N)
                    if p.ack != last_dupack or extents[0] + extents[2] < last_dupack_x:
                        drawable.draw_text(border_gc, small_playout, text, x, y, anchor=ANCHOR_N)
                        last_dupack = p.ack
                        last_dupack_x = extents[0] - 4
                if p.pure_ack():
                    drawable.draw_ack(gc1, x, y)
                else:
                    drawable.draw_dataack(gc2, x, y)

            # window line, if enabled
            if self.show_window and self.conn.has_window:
                windows = []; gc = drawable.gc("window")
                for p in self.conn.packets(1 - self.dir, t0, t1, fuzz=1):
                    x, y = int(p.time * tscale + toff), int((p.ack + p.window) * sscale + soff)
                    windows.append((x, y))
                drawable.clip(gc, drawable.plot_bounds())
                drawable.draw_lines(gc, windows)
                drawable.unclip(gc)

            # data packets
            gc = drawable.gc("data")
            for p in self.conn.packets(self.dir, t0, t1):
                drawable.draw_data(gc, p.time * tscale + toff, p.seq * sscale + soff, p.last_seq * sscale + soff)
            
        else:
            self.plotted = False

        drawable.complete()


    # higlights
    def _highlight_packet(self, p, dir):
        drawable = PlotCanvas_ScreenDrawable(self, immediate=True)
        gc = drawable.gc("highlight")

        if dir == self.dir:
            x, y1, y2 = self._transform(p.time, p.seq, p.last_seq)
            bounds = (x - 5, y2 - 5, 10, y1 - y2 + 10)
            drawable.fill_rectangle(gc, bounds)
            drawable.draw_data(drawable.gc("data.highlight"), x, y1, y2)
        else:
            x, y = self._transform(p.time, p.ack)
            bounds = (x - 5, y - 5, 10, 10)
            if p.dup_acks > 0:
                layout = drawable.layout("small")
                bounds = union_rectangle(bounds, expand_rectangle(drawable.text_extents(layout, str(p.dup_acks + 1), x, y, anchor=ANCHOR_N), 2))
            drawable.fill_rectangle(gc, bounds)
            if p.pure_ack():
                drawable.draw_ack(drawable.gc("ack.highlight"), x, y)
            else:
                drawable.draw_dataack(drawable.gc("dataack.highlight"), x, y)
            if p.dup_acks > 0:
                drawable.draw_text(drawable.gc("label"), layout, str(p.dup_acks + 1), x, y, anchor=ANCHOR_N)

        return bounds
    
    def draw_highlight(self):
        h = self.highlight
        if h[0] is None:
            self.highlight_bounds = None
        elif h[0] == 'packet':
            self.highlight_bounds = self._highlight_packet(h[1], h[2])
        elif h[0] == 'bandwidth':
            x, y = h[2], h[3]
            bounds = None
            if abs(x - self.press[0]) > PlotCanvas.DRAG_STICKINESS or abs(y - self.press[1]) > self.DRAG_STICKINESS:
                bounds = (min(x, self.press[0]), min(y, self.press[1]), abs(x - self.press[0]) + 1, abs(y - self.press[1]) + 1)
                drawable = PlotCanvas_ScreenDrawable(self, immediate=True)
                gc = drawable.gc("highlight")
                drawable.draw_line(gc, x, y, self.press[0], self.press[1])
            for old_h in h[4:]:
                if old_h[0] == 'packet':
                    bounds = union_rectangle(bounds, self._highlight_packet(old_h[1], old_h[2]))
            self.highlight_bounds = expand_rectangle(bounds, 2)
            
    def erase_highlight(self):
        if self.highlight_bounds is not None:
            self.expose_rectangle(self.highlight_bounds)
    def set_highlight(self, highlight):
        if highlight is None:
            highlight = [None]
        if self.highlight != highlight:
            self.erase_highlight()
            self.highlight = highlight
            self.draw_highlight()
            for f in self.highlight_hooks:
                f(self, self.highlight)

    def add_highlight_hook(self, f):
        self.highlight_hooks.append(f)


class PlotFlowWindow:
    
    def __init__(self, fset):
        self.flowset = fset
        self.flowid = None
        self.flowref = None
        
        win = gtk.Window()
        win.connect('destroy', self.cmd_exit)
        win.set_title("tcpplot")

        vbox = gtk.VBox()
        win.add(vbox)
        vbox.show()

        self._init_menus(win, vbox)
        self._init_toolbar(win, vbox)

        paned = gtk.VPaned()
        vbox.add(paned)
        paned.show()
        
        plotbox = self._init_plotbox()
        flowtree = self._init_flowtree()

        paned.add1(plotbox)
        paned.add2(flowtree)

        if len(fset):
            self.set_flow(id=0)
        else:
            self._activate_flow_items(None)

        win.show()

        self.canvas.grab_focus()

    def _init_menus(self, win, vbox):
        accel_group = gtk.AccelGroup()
        self.item_factory = gtk.ItemFactory(gtk.MenuBar, "<main>", accel_group)
        win.add_accel_group(accel_group)
        self.item_factory.create_items((
            ( "/_File",         None,         None, 0, "<Branch>" ),
   	    ( "/File/_Open",    "<control>O", None, 0, None ),
   	    ( "/File/sep1",     None,         None, 0, "<Separator>" ),
            ( "/File/Print",    "<control>P", self.cmd_print, 0, None ),
   	    ( "/File/sep2",     None,         None, 0, "<Separator>" ),
   	    ( "/File/Quit",     "<control>Q", self.cmd_exit, 0, "<StockItem>", gtk.STOCK_QUIT ),
            ( "/_Tools",	None,		None, 0, "<Branch>" ),
            ( "/Tools/_Identify", None,		self.cmd_menu_tool, 0, "<RadioItem>" ),
            ( "/Tools/_Move", None,		self.cmd_menu_tool, 0, "/Tools/Identify" ),
            ( "/_View",		None,		None, 0, "<Branch>" ),
            ( "/View/View _All", None, self.cmd_zoom_fit, 0, "<StockItem>", gtk.STOCK_ZOOM_FIT ),
            ( "/View/_Zoom In",	"<control>equal", self.cmd_zoom_in, 0, "<StockItem>", gtk.STOCK_ZOOM_IN ),
            ( "/View/Zoom _Out", "<control>minus", self.cmd_zoom_out, 0, "<StockItem>", gtk.STOCK_ZOOM_OUT ),
   	    ( "/View/sep1",     None,         None, 0, "<Separator>" ),
            ( "/View/_Next Flow", "<control>Right", self.cmd_next_flow, 0, "<StockItem>", gtk.STOCK_GO_FORWARD ),
            ( "/View/_Previous Flow", "<control>Left", self.cmd_prev_flow, 0, "<StockItem>", gtk.STOCK_GO_BACK ),
            ( "/View/_Swap Direction", None, self.cmd_swap_dir, 0, None ),
            ( "/View/sep2",	None, None, 0, "<Separator>" ),
            ( "/View/Hide Receive Window", None, self.cmd_toggle_receive_window, 0, None )
   	    ))
        menubar = self.item_factory.get_widget("<main>")
        vbox.pack_start(menubar, 0, 0)
        menubar.show()

        self.menu_tools = { }
        self.menu_tools[PlotCanvas.TOOL_IDENTIFY] = self.item_factory.get_item("/Tools/Identify")
        self.menu_tools[PlotCanvas.TOOL_HAND] = self.item_factory.get_item("/Tools/Move")

        self.rcv_window_item = self.item_factory.get_item("/View/Hide Receive Window")

    def _init_toolbar(self, win, vbox):
        toolbar = gtk.Toolbar()
        toolbar.set_style(gtk.TOOLBAR_BOTH)
        self.toolbar_tools = { }
        self.toolbar_tools[PlotCanvas.TOOL_IDENTIFY] = t = toolbar.append_element(gtk.TOOLBAR_CHILD_RADIOBUTTON, None, "Ident", "Identification tool: Move near a packet for information about it; drag for bandwidth measurement", "", stock_image(gtk.STOCK_ZOOM_IN), self.cmd_toolbar_tool, 0)
        self.toolbar_tools[PlotCanvas.TOOL_HAND] = toolbar.append_element(gtk.TOOLBAR_CHILD_RADIOBUTTON, t, "Move", "Move tool: Drag to shift window; control-click to zoom in; control-alt-click to zoom out", "", stock_image(gtk.STOCK_ZOOM_OUT), self.cmd_toolbar_tool, 0)
        toolbar.append_space()
        toolbar.append_item("In", "Zoom in slightly", "", stock_image(gtk.STOCK_ZOOM_IN), self.cmd_zoom_in, 0)
        toolbar.append_item("Out", "Zoom out slightly", "", stock_image(gtk.STOCK_ZOOM_OUT), self.cmd_zoom_out, 0)
        toolbar.append_item("All", "Show whole connection", "", stock_image(gtk.STOCK_ZOOM_FIT), self.cmd_zoom_fit, 0)
        toolbar.append_space()
        self.prev_flow_button = toolbar.append_item("Prev", "Switch to previous flow", "", stock_image(gtk.STOCK_GO_BACK), self.cmd_prev_flow, 0)
        self.next_flow_button = toolbar.append_item("Next", "Switch to next flow", "", stock_image(gtk.STOCK_GO_FORWARD), self.cmd_next_flow, 0)
        toolbar.append_item("Swap", "Show the other flow of this connection", "", file_image("double_arrow_small.png"), self.cmd_swap_dir, 0)
        vbox.pack_start(toolbar, 0, 0)
        toolbar.show()

    def _init_flowtree(self):
        scrolled_window = gtk.ScrolledWindow()
        scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        self.flowtree_model = FlowSetTreeModelByLosses(self.flowset)
        treeview = gtk.TreeView(self.flowtree_model)
        treeview.set_headers_visible(gtk.FALSE)
        cell1 = gtk.CellRendererText()
        # the text in the column comes from column 0
        column = gtk.TreeViewColumn("tuples", cell1, text=0)
        treeview.append_column(column)
        column = gtk.TreeViewColumn("tuples", cell1, text=1)
        treeview.append_column(column)
        column = gtk.TreeViewColumn("tuples", cell1, text=2)
        treeview.append_column(column)
        column = gtk.TreeViewColumn("tuples", cell1, text=3)
        treeview.append_column(column)
        treeview.show()

        scrolled_window.add(treeview)
        scrolled_window.show()

        treeview.connect("row_activated", self.cmd_flowtree_row_activated)
        return scrolled_window

    def _init_plotbox(self):
        frame = gtk.VBox()
        frame.show()
        
        self.canvas = PlotCanvas(frame)

        scale = gtk.HScrollbar(adjustment=self.canvas.get_time_adjustment())
        frame.pack_start(scale, 0, 0)
        scale.show()

        self.statusbar = gtk.Label("")
        self.statusbar.set_justify(gtk.JUSTIFY_LEFT)
        self.statusbar.set_alignment(0, 0.5)
        self.statusbar.set_padding(5, 3)
        frame.pack_start(self.statusbar, 0, 0)
        self.statusbar.show()

        self.canvas.add_highlight_hook(self.highlight_hook)
        return frame
        
    def cmd_exit(self, *args):
        gtk.main_quit()

    def cmd_print(self, widget, event):
        f = file("/tmp/tcpplot.ps", "w")
        self.canvas.plot(PlotCanvas_PostScriptDrawable(self.canvas, f))
        f.close()
        
    def cmd_zoom_in(self, widget, event):
        self.canvas.zoom(factor=0.75)

    def cmd_zoom_out(self, widget, event):
        self.canvas.zoom(factor=1.25)

    def cmd_zoom_fit(self, widget, event):
        self.canvas.view_all()

    def select_tool(self, tool):
        if self.canvas.tool != tool:
            self.canvas.select_tool(tool)
            self.toolbar_tools[tool].set_active(True)
            self.menu_tools[tool].set_active(True)

    def cmd_menu_tool(self, widget, toolbar):
        for e in self.menu_tools.items():
            if e[1].get_active(): self.select_tool(e[0])
    def cmd_toolbar_tool(self, widget, toolbar):
        for e in self.toolbar_tools.items():
            if e[1].get_active(): self.select_tool(e[0])

    def _activate_flow_items(self, fref):
        self.item_factory.get_item("/View/Next Flow").set_sensitive(self.flowid < len(self.flowset) - 1)
        self.next_flow_button.set_sensitive(self.flowid < len(self.flowset) - 1)
        self.item_factory.get_item("/View/Previous Flow").set_sensitive(self.flowid > 0)
        self.prev_flow_button.set_sensitive(self.flowid > 0)
        self.rcv_window_item.set_sensitive(fref is not None and fref.has_window())

    def connection(self):
        if self.flowid is None:
            return None
        else:
            return self.flowref.conn

    def statusbar_description(self):
        desc = self.flowref.get_description()
        desc = re.sub("<", "&lt;", desc)
        desc = re.sub("(^\\#[0-9]+)", "<b>\\1</b>", desc)
        self.statusbar.set_markup(desc)
        
    def set_flow(self, id=None, fref=None, keeptime=False):
        if id is None: id = self.flowset.index(fref)
        if fref is None: fref = self.flowset[id]

        oc = self.connection()
        if oc is not fref.conn and oc is not None:
            oc.unload()
        
        self.canvas.set_flowref(fref, keeptime)
        
        self.flowid = id
        self.flowref = fref
        self._activate_flow_items(fref)
        self.statusbar_description()

    def cmd_next_flow(self, widget, event):
        self.set_flow(id=self.flowid + 1)

    def cmd_prev_flow(self, widget, event):
        self.set_flow(id=self.flowid - 1)

    def cmd_swap_dir(self, widget, event):
        self.set_flow(fref=self.flowref.opposite(), keeptime=True)

    def cmd_flowtree_row_activated(self, widget, path, column):
        self.set_flow(fref=self.flowtree_model.path2flowref(path))

    def cmd_toggle_receive_window(self, widget, event):
        self.canvas.set_show_window(not self.canvas.get_show_window())
        self.item_factory.get_item("/View/Hide Receive Window").get_child().set_label(["Show Receive Window", "Hide Receive Window"][self.canvas.get_show_window()])

    def highlight_hook(self, plotcanvas, highlight):
    	if highlight[0] == "packet":
            p, dir = highlight[1:]
            if dir == self.flowref.dir:
                desc = "%.06fs: <b>Data</b> at %d:%d (+%d)" % (p.time, int(p.seq), int(p.last_seq), int(p.last_seq - p.seq))
            else:
                desc = "%.06fs: <b>Ack</b> for %d" % (p.time, int(p.ack))
                if p.dup_acks > 0:
                    desc += " (" + ordinal(p.dup_acks + 1) + " dup)"
                if not p.pure_ack():
                    desc += " with data (+%d)" % (p.last_seq - p.seq)
            self.statusbar.set_markup("<span foreground='#000099'>" + desc + "</span>")
        elif highlight[0] == "bandwidth":
            bw = highlight[1]
            if bw <= 0: desc = "-"
            elif bw < 1024: desc = "%d B/s" % bw
            elif bw < 1048576: desc = "%.3f KB/s" % (bw/1024.)
            else: desc = "%.3f MB/s" % (bw/1048576.)
            self.statusbar.set_markup("<span foreground='#000099'>Bandwidth: <b>" + desc + "</b></span>")
        else:
            self.statusbar_description()


if __name__ == "__main__":
    all_connections = FlowSet()
    try:
        if len(sys.argv) >= 2:
            f = uncompressed_file(sys.argv[1])
            c = f.read(1)
            f.seek(0)
            if c == '<':
                all_connections.read(f)
            else:
                all_connections.append(Connection(sys.argv[1]))
        else:
            all_connections.append(Connection(sys.stdin))
        all_connections.sort_by_loss_count()
        window = PlotFlowWindow(all_connections)
        gtk.main()
    except KeyboardInterrupt:
        gtk.main_quit()

# 1752 >
# 1
