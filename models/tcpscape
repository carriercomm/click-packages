#!/usr/bin/env python

from __future__ import generators
import sys, re, types, string, struct, gzip
sys.path[0:0] = ['/usr/lib/python2.2/site-packages/gtk-2.0']
from bisect import bisect
from math import *
import gtk, gobject, pango, xml.parsers.expat

_screen_fill_colors = {
    "data": "red", "ack": "dark green", "dataack": "blue",
    "loss": "gold", "loss.bg": "khaki",
    "ploss": "mint cream",
    "floss": "grey80", "floss.bg": "grey90",
    "border": "dark grey", "lossborder": "yellow",
    "bg": "white"
}
_screen_dashes = {
    "lossborder": [4, 4]
}


def frange(start, stop, step):
    i = 0
    while True:
        pos = start + i * step
        if pos > stop:
            break
        yield pos
        i += 1

def uncompressed_file(filename):
    f = file(filename, "rb")
    twochars = f.read(2)
    f.seek(0)
    if twochars == "\037\235" or twochars == "\037\213":
        return gzip.GzipFile(fileobj=f)
    else:
        return f


class Packet:
    def __init__(self, time, flags, seq, payloadlen, ack, dup_acks=0):
        self.time = float(time)
        self.seq = float(seq)
        self.last_seq = self.seq + int(payloadlen)
        self.ack = float(ack)
        if flags != "A" and flags != "PA":
            if flags.find("S") >= 0:
                self.last_seq += 1
            if flags.find("F") >= 0:
                self.last_seq += 1
        self.dup_acks = int(dup_acks)
    def pure_ack(self):
        return self.seq == self.last_seq
    def has_data(self):
        return self.seq != self.last_seq
    def __cmp__(self, other):
        return self.time.__cmp__(other.time)
    def __str__(self):
        result = "[" + str(self.time) + " "
        if self.pure_ack():
            result += "A" + str(self.ack)
        else:
            result += str(self.seq) + ":" + str(self.last_seq)
        return result + "]"

class LossEvent:
    def __init__(self, type, begin, seq, end, end_seq):
        self.type, self.begin, self.seq, self.end, self.end_seq = \
                   type, float(begin), float(seq), float(end), float(end_seq)
    def time_overlaps(self, begin, end):
        return (begin is None or self.end >= begin) and (end is None or end >= self.begin);
    def fillcolor(self):
        return fill_colors[self.type]


class ConnectionFormatError(Exception):
    def __init__(self, s=""):
        self.str = s
    def __str__(self):
        return `self.str`
class ConnectionFileCompressedError(ConnectionFormatError):
    def __init__(self, s=""):
        self.str = s
    def __str__(self):
        return `self.str`

def direction(dir):
    if dir == '>':
        return 0
    elif dir == '<':
        return 1
    elif dir is True:
        return 0
    elif dir is False:
        return 1
    elif int(dir) == 0 or int(dir) == 1:
        return int(dir)
    else:
        raise ConnectionFormatError, "bad direction " + `dir`


def unparse_tcp_flags(flags):
    return ("", "F", "S", "FS", "R", "FR", "SR", "FSR",
            "P", "FP", "SP", "FSP", "RP", "FRP", "SRP", "FSRP")[flags & 15] \
        + ("", "A", "U", "AU", "E", "AE", "UE", "AUE",
           "W", "AW", "UW", "AUW", "EW", "AEW", "UEW", "AUEW")[(flags >> 4) & 15]

class Connection:
    
    def __init__(self, f=None, aggregate=-1, src=None, sport=None, dst=None, dport=None):
        self.s = ([], [])
        self.loss = ([], [])
        self.available = False
        if src is not None:
            self.flowid = (src, int(sport), dst, int(dport))
        else:
            self.flowid = None
        self.aggregate = aggregate
        self.loss_count = [0, 0]
        if type(f) == types.FileType:
            self.read(f)
        else:
            self.filename = f

    class Fileboy:
        def __init__(self, f):
            self.f = f
            self.str = ""
            self.pos = 0
        def __iter__(self):
            return self
        def next(self):
            while True:
                eol = self.str.find("\n", self.pos)
                if eol >= 0:
                    p, self.pos = self.pos, eol + 1
                    return self.str[p:self.pos]
                if self.pos > 0:
                    self.str = self.str[self.pos:]
                    self.pos = 0
                p = len(self.str)
                self.str += self.f.read(32768)
                if len(self.str) == 0:
                    raise StopIteration
                elif len(self.str) == p:
                    self.pos = p
                    return self.str
        def read(self):
            p, self.pos = self.pos, len(self.str)
            return self.str[p:] + self.f.read()
    
    def _check_data(self):
        if self.read_state == "a":      # ASCII
            x = '!data timestamp direction tcp_flags tcp_seq payload_len tcp_ack'
        elif self.read_state == "b":    # binary
            x = '!data timestamp tcp_seq payload_len tcp_ack tcp_flags direction'
        else:
            return
        if not re.match(x, self.read_data):
            raise ConnectionFormatError, "bad !data"
    
    def _read_nonpacket(self, line):
        if re.match('\\#[pf]?loss', line):
            type, dir, time, seq, end_time, end_seq = line[1:].split()[:6]
            self.loss[direction(dir)].append(LossEvent(type, time, seq, end_time, end_seq))
        elif re.match('!flowid', line):
            fid = line.split()[1:5]
            self.flowid = (fid[0], int(fid[1]), fid[2], int(fid[3]))
        elif re.match('!aggregate', line):
            self.aggregate = int(line.split()[1])
        elif re.match('!data ', line):
            self.read_data = line
            self._check_data()
        elif re.match('!eof$', line):
            return 1
        elif line[:2] == "\037\235" or line[:2] == "\037\213": # compressed data
            raise ConnectionFileCompressedError
        return 0

    def _read_binary(self, f):
        self.read_state = "b"
        self._check_data()

        last_ack = [-1, -1]; dup_acks = [0, 0]
        data = f.read()
        pos, leng = 0, len(data)
        while pos + 4 < leng:
            l, = struct.unpack("!l", data[pos:pos+4])
            i = l & 0x7FFFFFFF
            if pos + i > leng:
                raise ConnectionFormatError, "corrupted file"
            elif l & 0x80000000:
                if self._read_nonpacket(data[pos+4:pos+i]):
                    break
            elif i >= 26:
                ts_sec, ts_usec, seq, payloadlen, ack, flags, dir = \
                   struct.unpack("!LLLLLBB", data[pos+4:pos+26])
                time = ts_sec + ts_usec / 1000000.
                if flags == 16: flags = "A"
                else: flags = unparse_tcp_flags(flags)
                if ack == last_ack[dir]: dup_acks[dir] += 1
                else: dup_acks[dir] = 0; last_ack[dir] = ack
                self.s[dir].append(Packet(time, flags, seq, payloadlen, ack, dup_acks[dir]))
            pos += i

    def read(self, f):
        last_ack = [-1, -1]; dup_acks = [0, 0]
        read_state = 0; self.read_state = ""; self.read_data = ""
        f = Connection.Fileboy(f)
        for line in f:
            if line and line[0] >= '0' and line[0] <= '9':
                if read_state == 0:
                    read_state = 1; self.read_state = "a"
                    self._check_data()
                time, dir, flags, seq, payloadlen, ack = line.split()
                dir, ack = direction(dir), int(ack)
                if ack == last_ack[dir]: dup_acks[dir] += 1
                else: dup_acks[dir] = 0; last_ack[dir] = ack
                self.s[dir].append(Packet(time, flags, seq, payloadlen, ack, dup_acks[dir]))
            elif re.match('!binary', line):
                self.read_state = "b"
                break
            elif self._read_nonpacket(line):
                break
        if self.read_state == "b":
            self._read_binary(f)
        self.available = True
        del self.read_state
        del self.read_data
        return self
    
    def first_index_after(self, time, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            return self.first_index_after(time, 0), self.first_index_after(time, 1)
        else:
            fake_pkt = Packet(time, "A", 0, 0, 0)
            return bisect(self.s[direction(dir)], fake_pkt)
    
    def packets(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        if begin is None:
            i = 0
        else:
            i = self.first_index_after(begin, dir)
        while i < len(self.s[dir]) and (end is None or self.s[dir][i].time <= end):
            yield self.s[dir][i]
            i += 1
    
    def rev_packets(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        if end is None:
            i = len(self.s[dir]) - 1
        else:
            i = self.first_index_after(end, dir) - 1
        while i >= 0 and (begin is None or self.s[dir][i].time >= begin):
            yield self.s[dir][i]
            i -= 1
    
    def losses(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        for l in self.loss[dir]:
            if l.time_overlaps(begin, end):
                yield l
    
    def get_time_range(self, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            m0, M0 = self.get_time_range(0)
            m1, M1 = self.get_time_range(1)
            return min(m0, m1), max(M0, M1)
        elif len(self.s[dir]) == 0:
            return 0, 1
        else:
            dir = direction(dir)
            return self.s[dir][0].time, self.s[dir][-1].time
    
    def _time_index(self, dir, time, after):
        if time is not None:
            return self.first_index_after(time, dir)
        elif after:
            return len(self.s[dir])
        else:
            return 0
    
    def _seq_range(self, dir, begin, end):
        s0, s1 = 1e10, 0.
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].seq - 10)
            s1 = max(s1, self.s[dir][i].last_seq + 10)
        for l in self.losses(dir, begin, end):
            s0 = min(s0, l.seq - 10)
            s1 = max(s1, l.end_seq + 10)
        return max(s0, 0.), s1
    
    def _ack_range(self, dir, begin, end):
        s0, s1 = 1e10, 0.
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].ack - 10)
            s1 = max(s1, self.s[dir][i].ack + 10)
        return max(s0, 0.), s1
    
    def get_seq_range(self, dir=None, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        r0, r1 = self._seq_range(dir, begin, end), self._ack_range(1 - dir, begin, end)
        return min(r0[0], r1[0]), max(r0[1], r1[1])
    
    def get_description(self):
        if self.flowid is None:
            self.load()
        s = ""
        if self.aggregate >= 0:
            s += "#" + `self.aggregate` + ": "
        return s + self.flowid[0] + ":" + str(self.flowid[1]) + " > " + self.flowid[2] + ":" + str(self.flowid[3])
    
    def get_flowid_text(self, dir=0):
        if self.flowid is None:
            self.load()
        dirstr = "><"[direction(dir)]
        return self.flowid[0] + ":" + str(self.flowid[1]) + " " + dirstr + " " + self.flowid[2] + ":" + str(self.flowid[3])
    
    def load(self):
        if type(self.filename) != types.StringType:
            raise RuntimeError, "cannot load this Connection " + self.filename
        elif not self.available:
            f = file(self.filename, 'rb')
            try:
                self.read(f)
            except ConnectionFileCompressedError:
                f.seek(0)
                self.read(gzip.GzipFile(fileobj=f))
            f.close()
    
    def unload(self):
        if type(self.filename) == types.StringType:
            self.s = ([], [])
            self.loss = ([], [])
            self.available = False


class FlowRef:

    def __init__(self, conn, dir):
        self.conn, self.dir, self.plotboxes = conn, dir, []

    def loss_count(self):
        return self.conn.loss_count[self.dir]

    def aggregate(self):
        return self.conn.aggregate

    def get_flowid_text(self):
        return self.conn.get_flowid_text(self.dir)

    def get_description(self):
        s = self.conn.get_description()
        if self.dir:
            s = re.sub(" > ", " < ", s)
        return s
    
    def opposite(self):
        return FlowRef(self.conn, 1 - self.dir)
    
    def unload(self):
        self.conn.unload()

    def add_plotbox(self, plotbox):
        self.plotboxes.append(plotbox)

    def del_plotbox(self, plotbox):
        self.plotboxes.remove(plotbox)

    def shown(self):
        return len(self.plotboxes) > 0

    def __cmp__(self, other):
        if self.conn is other.conn:
            return self.dir - other.dir
        elif self.conn < other.conn:
            return -1
        else:
            return 1

    def __str__(self):
        fid = self.conn.flowid
        return "<#%d: %s:%s %s %s:%s>" % (self.conn.aggregate, fid[0], fid[1], "><"[self.dir], fid[2], fid[3])


class FlowSet:
    
    def __init__(self, f=None):
        self.conns = []
        self.flows = []
        self.sum_loss_count = [0, 0, 0]
        if type(f) == types.StringType:
            slash = f.rfind('/')
            if slash >= 0: dir = f[:slash+1]
            else: dir = ''
            self.read(file(f), dir=dir)
        elif f is not None:
            self.read(f)

    def read(self, f, dir=''):
        self.reading_directory = dir
        p = xml.parsers.expat.ParserCreate()
        p.returns_unicode = 0
        p.StartElementHandler = self._start_element
        p.EndElementHandler = self._end_element
        self.reading_state = 0
        self.reading_connection = None
        p.ParseFile(f)

    def _handle_number(self, x, format, precision):
        if precision >= 0 and precision <= 3:
            x = (self >> ((3 - precision) * 8)) & 255
        elif precision >= 4 and precision <= 5:
            x = (self >> ((5 - precision) * 16)) & 65535
        if format == 'n':
            return str(x)
        else:
            return ('%' + format) % x

    def _handle_ip(self, x, precision):
        if precision >= 0 and precision <= 3:
            return x.split('.')[precision]
        else:
            return x

    def _expand_filename(self, aggregate, src, sport, dst, dport):
        s = self.reading_output_pattern
        ss = ''
        pos = s.find('%')
        while pos >= 0:
            ss += s[:pos]; pos += 1
            pad, field_width, precision = ' ', 0, -1
            if s[pos:pos+1] == '0': pad = '0'; pos += 1
            while s[pos:pos+1] >= '0' and s[pos:pos+1] <= '9': field_width = (field_width * 10) + ord(s[pos:pos+1]) - ord('0'); pos += 1
            if s[pos:pos+1] == '.': precision = int(s[pos+1:pos+2]); pos += 2
            x = s[pos:pos+1]
            if x in ['n', 'x', 'X']:
                q = self._handle_number(aggregate, x, precision)
            elif x == 's':
                q = self._handle_ip(src, precision)
            elif x == 'd':
                q = self._handle_ip(dst, precision)
            elif x == 'S':
                q = self._handle_number(sport, 'n', precision)
            elif x == 'D':
                q = self._handle_number(dport, 'n', precision)
            elif x == 'p':
                q = 'T'
            else:
                q = x
            if field_width > len(q): q = (pad * (field_width - len(q))) + q
            ss += q
            s = s[pos+1:]
            pos = s.find('%')
        return self.reading_directory + ss + s

    def _start_element(self, name, attrs):
        if name == 'connections':
            if self.reading_state != 0:
                raise ConnectionFormatError, "nested <connections>"
            self.reading_output_pattern = attrs["filepattern"]
            self.reading_state = 1
        elif name == 'connection' and self.reading_state == 1:
            agg, src, sport, dst, dport = int(attrs["aggregate"]), attrs["src"], int(attrs["sport"]), attrs["dst"], int(attrs["dport"])
            self.reading_connection = Connection(self._expand_filename(agg, src, sport, dst, dport), aggregate=agg, src=src, sport=sport, dst=dst, dport=dport)
            self.conns.append(self.reading_connection)
            self.flows.append(FlowRef(self.reading_connection, 0))
            self.flows.append(FlowRef(self.reading_connection, 1))
        elif name == 'flow' and self.reading_connection is not None:
            try:
                d, l, pl, fl = int(attrs["dir"]), int(attrs["loss"]), int(attrs["ploss"]), int(attrs["floss"])
                self.reading_connection.loss_count[d] += l + pl + fl
                self.sum_loss_count[0] += l
                self.sum_loss_count[1] += pl
                self.sum_loss_count[2] += fl
            except KeyError:
                pass

    def _end_element(self, name):
        if name == 'connections':
            self.reading_state = 0
        elif name == 'connection':
            self.reading_connection = None

    def sort_by_loss_count(self):
        self.flows.sort(lambda a, b: b.loss_count().__cmp__(a.loss_count()) or a.aggregate().__cmp__(b.aggregate()))

    def __getitem__(self, k):
        if type(k) == types.SliceType:
            return self.flows[k.start:k.stop]
        else:
            return self.flows[k]

    def __len__(self):
        return len(self.flows)

    def append(self, conn):
        self.conns.append(conn)
        self.flows.append(FlowRef(conn, 0))
        self.flows.append(FlowRef(conn, 1))


_by_loss_groups = [ (50, "50 or more losses"),
                    (30, "30-49 losses"),
                    (20, "20-29 losses"),
                    (10, "10-19 losses"),
                    (5, "5-9 losses"),
                    (4, "4 losses"),
                    (3, "3 losses"),
                    (2, "2 losses"),
                    (1, "1 loss"),
                    (0, "no losses") ]

class FlowSetTreeModelByLosses(gtk.GenericTreeModel):
    '''This class represents the model of a tree.  The iterators used
    to represent positions are converted to python objects when passed
    to the on_* methods.  This means you can use any python object to
    represent a node in the tree.  The None object represents a NULL
    iterator.'''

    def __init__(self, flowset):
	'''constructor for the model.  Make sure you call
	PyTreeModel.__init__'''
        self.flowset = flowset
        self.analyze_flowset()
	gtk.GenericTreeModel.__init__(self)

    def analyze_flowset(self):
        self.cg = []
        self.gn = []
        if self.flowset is not None and len(self.flowset) > 0:
            self.flowset.sort_by_loss_count()
            i = 0; first = 0; lc = self.flowset[i].loss_count()
            blg = 0; min_losses = _by_loss_groups[blg][0]
            while i < len(self.flowset):
                f = self.flowset[i]
                if f.loss_count() < min_losses:
                    if first < i:
                        self.gn.append(_by_loss_groups[blg][1])
                        self.cg.append(self.flowset[first:i])
                        first = i
                    blg += 1; min_losses = _by_loss_groups[blg][0]
                else:
                    i += 1
            if first < i:
                self.gn.append(_by_loss_groups[blg][1])
                self.cg.append(self.flowset[first:i])

    # the implementations for TreeModel methods are prefixed with on_
    def on_get_flags(self):
	'''returns the GtkTreeModelFlags for this particular type of model'''
	return 0
    def on_get_n_columns(self):
	'''returns the number of columns in the model'''
	return 3
    def on_get_column_type(self, index):
	'''returns the type of a column in the model'''
	return gobject.TYPE_STRING
    
    def on_get_path(self, node):
	'''returns the tree path (a tuple of indices at the various
	levels) for a particular node.'''
        return node
    def on_get_iter(self, path):
        '''returns the node corresponding to the given path.  In our
        case, the node is the path'''
        return path

    def path2flowref(self, n):
        assert len(n) == 2
        return self.cg[n[0]][n[1]]
    def flowref2path(self, fref):
        lc = fref.loss_count()
        i = 0
        while i < len(self.cg) and lc < self.cg[i][-1].loss_count():
            i += 1
        if i >= len(self.cg):
            return None
        for j in range(0, len(self.cg[i])):
            if self.cg[i][j] == fref:
                return (i, j)
        return None
    
    def on_get_value(self, n, column):
	'''returns the value stored in a particular column for the node'''
        if len(n) == 1:
            if column == 1:
                return self.gn[n[0]]
            else:
                return ''
        elif column == 0:
            if self.path2flowref(n).shown():
                return 'X'
            else:
                return ''
        elif column == 1:
            l = self.path2flowref(n).loss_count()
            if l == 1:
                return '1 loss'
            else:
                return `l` + ' losses'
        elif column == 2:
            return '#' + `self.path2flowref(n).aggregate()`
        else:
            return self.path2flowref(n).get_flowid_text()
            
    def on_iter_next(self, n):
	'''returns the next node at this level of the tree'''
        if len(n) == 1 and n[0] < len(self.cg) - 1:
            return n[0]+1,
        elif len(n) == 2 and n[1] < len(self.cg[n[0]]) - 1:
            return n[0], n[1]+1
        else:
            return None
    def on_iter_children(self, n):
	'''returns the first child of this node'''
        if n is None:
            if len(self.cg) > 0:
                return 0,
        elif len(n) == 1:
            return n + (0,)
        return None
    def on_iter_has_child(self, n):
	'''returns true if this node has children'''
        if n is None:
            return len(self.cg) > 0
        else:
            return len(n) == 1
    def on_iter_n_children(self, n):
	'''returns the number of children of this node'''
        if n is None:
            return len(self.cg)
        elif len(n) == 1:
            return len(self.cg[n[0]])
        else:
            return 0
    def on_iter_nth_child(self, n, i):
	'''returns the nth child of this node'''
        if n is None:
            return i,
        elif len(n) == 1 and i < len(self.cg[n[0]]):
            return n + (i,)
        else:
            return None
    def on_iter_parent(self, n):
	'''returns the parent of this node'''
	if len(n) == 0:
	    return None
	else:
	    return n[:-1]



def fix_range(a, b, min_step_frac):
    d = b - a
    step = 10 ** floor(log10(d))

    # make step bigger if required
    if step / d > 0.5 and step / d >= min_step_frac:
        if step/5 / d >= min_step_frac:
            step /= 5
        elif step/2.5 / d >= min_step_frac:
            step /= 2.5
        elif step/2 / d >= min_step_frac:
            step /= 2
    while step < d and step / d < min_step_frac:
        if 2*step / d >= min_step_frac:
            step *= 2
        elif 2.5*step / d >= min_step_frac:
            step *= 2.5
        elif 5*step / d >= min_step_frac:
            step *= 5
        else:
            step *= 10
    if step >= d:
        step = d

    # bound a and b to multiples of step, if appropriate
    a_try = floor(a / step) * step
    if a - a_try < 0.1*d:
        a = a_try; d = b - a
    b_try = ceil(b / step) * step
    if b_try - b < 0.1*d:
        b = b_try
    
    # return a dictionary
    return { "low": a, "high": b, "step": step }


_plot_cursors = {
    "zoomin": ("zoomin_data", "zoom_mask", 6, 6),
    "zoomout": ("zoomout_data", "zoom_mask", 6, 6),
    "hand": ("hand_data", "hand_mask", 9, 8),
    "grabhand": ("grabhand_data", "grabhand_mask", 8, 7),
    "zoomin_data": (string.join(map(chr, [
	0xf0, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x04, 0x00, 0x62, 0x04, 0x00,
        0x61, 0x08, 0x00, 0xf9, 0x09, 0x00, 0xf9, 0x09, 0x00, 0x61, 0x08, 0x00,
        0x62, 0x04, 0x00, 0x02, 0x04, 0x00, 0x0c, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00 ]), ''), 17, 17),
    "zoomout_data": (string.join(map(chr, [
	0xf0, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x04, 0x00, 0x02, 0x04, 0x00,
        0x01, 0x08, 0x00, 0xf9, 0x09, 0x00, 0xf9, 0x09, 0x00, 0x01, 0x08, 0x00,
        0x02, 0x04, 0x00, 0x02, 0x04, 0x00, 0x0c, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00 ]), ''), 17, 17),
    "zoom_mask": (string.join(map(chr, [
        0xf0, 0x00, 0x00, 0xfc, 0x03, 0x00, 0xfe, 0x07, 0x00, 0xfe, 0x07, 0x00,
        0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00,
        0xfe, 0x07, 0x00, 0xfe, 0x07, 0x00, 0xfc, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00]), ''), 17, 17),
    "hand_data": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x1c, 0x00, 0xc8, 0x24, 0x00,
        0xc8, 0xa4, 0x00, 0x90, 0x64, 0x01, 0x90, 0x24, 0x01, 0x2c, 0x20, 0x01,
        0x32, 0x00, 0x01, 0x22, 0x80, 0x00, 0x04, 0x80, 0x00, 0x08, 0x80, 0x00,
        0x08, 0x40, 0x00, 0x10, 0x40, 0x00, 0x20, 0x20, 0x00, 0x40, 0x20, 0x00,
        0x40, 0x20, 0x00, 0x00, 0x00, 0x00]), ''), 18, 18),
    "hand_mask": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x1f, 0x00, 0xf8, 0x3f, 0x00,
        0xf8, 0xbf, 0x00, 0xf0, 0xff, 0x01, 0xf0, 0xff, 0x01, 0xec, 0xff, 0x01,
        0xfe, 0xff, 0x01, 0xfe, 0xff, 0x00, 0xfc, 0xff, 0x00, 0xf8, 0xff, 0x00,
        0xf8, 0x7f, 0x00, 0xf0, 0x7f, 0x00, 0xe0, 0x3f, 0x00, 0xc0, 0x3f, 0x00,
        0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00]), ''), 18, 18),
    "grabhand_data": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0d, 0x48, 0x12,
        0x08, 0x30, 0x0c, 0x40, 0x0a, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x20,
        0x04, 0x20, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10]), ''), 16, 16),
    "grabhand_mask": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0d, 0xf8, 0x1f,
        0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x3f,
        0xfc, 0x3f, 0xf8, 0x1f, 0xf0, 0x1f, 0xf0, 0x1f]), ''), 16, 16)
    }
class PlotCursors:
    def __init__(self, win):
        self.window = win
    def make_pixmap(self, name):
        if name + ".pix" not in _plot_cursors:
            l = _plot_cursors[name]
            _plot_cursors[name + ".pix"] = gtk.gdk.bitmap_create_from_data(self.window.window, l[0], l[1], l[2])
    def __getitem__(self, name):
        if name + ".cur" not in _plot_cursors:
            data, mask, hotx, hoty = _plot_cursors[name]
            self.make_pixmap(data)
            self.make_pixmap(mask)
            black = self.window.get_style().black
            white = self.window.get_style().white
            _plot_cursors[name + ".cur"] = gtk.gdk.Cursor(_plot_cursors[data + ".pix"], _plot_cursors[mask + ".pix"], black, white, hotx, hoty)
        return _plot_cursors[name + ".cur"]




_screen_gcs = { }
ANCHOR_N = 0
ANCHOR_E = 1

class PlotCanvas_ScreenDrawable:

    def __init__(self, plotcanvas):
        self.plotcanvas = plotcanvas
        self.playout = None
        self.small_playout = None

    def gc(self, name):
        if name in _screen_gcs:
            return _screen_gcs[name]
        if name not in _screen_fill_colors:
            name = re.sub("\\..*", "", name)
        if name not in _screen_fill_colors:
            raise RuntimeError("bad gc name " + name)
        cmap = self.plotcanvas.canvas.get_colormap()
        gc = self.plotcanvas.canvas.window.new_gc(foreground=cmap.alloc_color(_screen_fill_colors[name]), line_width=0, cap_style=gtk.gdk.CAP_BUTT)
        if name in _screen_dashes:
            gc.line_style = gtk.gdk.LINE_ON_OFF_DASH
            gc.set_dashes(0, _screen_dashes[name])
        _screen_gcs[name] = gc
        return gc

    def layout(self, name=""):
        if name == "small":
            if self.small_playout is None:
                new_pcontext = self.plotcanvas.canvas.create_pango_context()
                new_pfontdesc = new_pcontext.get_font_description().copy()
                new_pfontdesc.set_size(new_pfontdesc.get_size() * 0.75)
                new_pcontext.set_font_description(new_pfontdesc)
                self.small_playout = pango.Layout(new_pcontext)
            return self.small_playout
        elif name == "":
            if self.playout is None:
                self.playout = self.plotcanvas.canvas.create_pango_layout("")
            return self.playout
        else:
            raise RuntimeError("bad layout name " + name)

    def prepare(self):
        self.drawable = self.plotcanvas.canvas.window
    
    def clear(self):
        self.drawable.clear()
    
    def draw_line(self, gc, x1, y1, x2, y2):
        self.drawable.draw_line(gc, x1, y1, x2, y2)

    def fill_rectangle(self, gc, x1, y1, w, h):
        self.drawable.draw_rectangle(gc, gtk.TRUE, x1, y1, w, h)

    def draw_rectangle(self, gc, x1, y1, w, h):
        self.drawable.draw_rectangle(gc, gtk.FALSE, x1, y1, w, h)

    def draw_text(self, gc, layout, text, x, y, anchor=ANCHOR_N):
        layout.set_text(text, -1)
        ir, lr = layout.get_extents()
        if anchor == ANCHOR_N:
            self.drawable.draw_layout(gc, x - lr[2]/2048.0, y + 2, layout)
        elif anchor == ANCHOR_E:
            self.drawable.draw_layout(gc, x - 4 - lr[2]/1024.0, y - lr[3]/2048.0, layout)
        else:
            raise RuntimeError("bad anchor " + str(anchor))

    def text_extents(self, layout, text, x, y, anchor=ANCHOR_N):
        layout.set_text(text, -1)
        ir, lr = layout.get_extents()
        if anchor == ANCHOR_N:
            return (x - lr[2]/2048.0, y + 2, x + lr[2]/2048.0, y + 2 + lr[3]/1024.0)
        elif anchor == ANCHOR_E:
            return (x - 4 - lr[2]/1024.0, y - lr[3]/2048.0, x - 4, y + lr[3]/2048.0)
        else:
            raise RuntimeError("bad anchor " + str(anchor))


class PlotCanvas:

    # initialization
    def __init__(self, master, width=600, height=500):
        self.canvas = gtk.DrawingArea()
        self.canvas.set_size_request(width, height)
        self.canvas.set_flags(gtk.CAN_FOCUS)

        self.canvas.connect("configure_event", self.cmd_configure)
        self.canvas.connect("expose_event", self.cmd_expose)
        self.canvas.connect("button_press_event", self.cmd_press)
        self.canvas.connect("motion_notify_event", self.cmd_motion)
        self.canvas.connect("button_release_event", self.cmd_release)
        self.canvas.connect("key_press_event", self.cmd_check_state_focus)
        self.canvas.connect("key_release_event", self.cmd_check_state_focus)
        self.canvas.connect("enter_notify_event", self.cmd_check_state)
        self.canvas.set_events(gtk.gdk.EXPOSURE_MASK | gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK | gtk.gdk.ENTER_NOTIFY_MASK | gtk.gdk.LEAVE_NOTIFY_MASK | gtk.gdk.KEY_PRESS_MASK | gtk.gdk.KEY_RELEASE_MASK | gtk.gdk.BUTTON1_MOTION_MASK | gtk.gdk.POINTER_MOTION_HINT_MASK)
        
        master.pack_start(self.canvas, expand=1, fill=1)
        self.canvas.show()

        self.left_margin = 40
        self.right_margin = 20
        self.top_margin = 10
        self.bottom_margin = 20
        self.plotted = False
        self.press_x = None
        self.press_state = 0
        self.mod_state = 0

    # getting properties
    def get_direction(self):
        return self.dir
    def get_flowref(self):
        return FlowRef(self.conn, self.dir)
    def get_time_range(self):
        if self.plotted:
            return (self.left_margin - self.toff) / self.tscale, (self.left_margin + self.plot_width - self.toff) / self.tscale
        else:
            return self.begin, self.end

    # setting properties
    def set_flowref(self, fref, begin=None, end=None):
        self.conn, self.dir = fref.conn, fref.dir
        self.set_time_range(begin, end)
    def set_direction(self, dir):
        self.dir = direction(dir)
        if self.plotted: self.plot()
    def set_time_range(self, begin, end):
        if begin is None: begin = self.conn.get_time_range()[0]
        if end is None: end = self.conn.get_time_range()[1]
        self.begin, self.end = begin, end
        if self.plotted: self.plot()

    def grab_focus(self):
        self.canvas.grab_focus()

    def cmd_configure(self, widget, event):
        x, y, self.wwidth, self.wheight = widget.get_allocation()

        # xxx
        self.canvas.window.set_cursor(PlotCursors(self.canvas)["hand"])
        
        self.plot_width = self.wwidth - self.left_margin - self.right_margin
        self.plot_height = self.wheight - self.top_margin - self.bottom_margin
    def cmd_expose(self, widget, event):
        self.plot()

    def _itransform(self, x, y, constrain=True):
        if self.plotted and (not constrain or (x >= self.left_margin and x <= self.left_margin + self.plot_width and y >= self.top_margin and y <= self.top_margin + self.plot_height)):
            return (x - self.toff) / self.tscale, (y - self.soff) / self.sscale
        else:
            raise ValueError
    def cmd_press(self, widget, event):
        try:
            if event.button == 1:
                self._itransform(event.x, event.y) # for signal
                self.press_x = event.x
                if not (event.state & (gtk.gdk.CONTROL_MASK | gtk.gdk.SHIFT_MASK)):
                    self.canvas.window.set_cursor(PlotCursors(self.canvas)["grabhand"])
        except ValueError:
            self.press_x = None
        self.stuck = True
        self.press_state = event.state
        self.grab_focus()
        return 1
    def cmd_motion(self, widget, event):
        try:
            x, y, state = widget.window.get_pointer()
            if (state & gtk.gdk.BUTTON1_MASK) and self.plotted and self.press_x is not None:
                if self.stuck and (abs(self.press_x - x) > 5):
                    self.stuck = False
                    self.drag_t0 = self.get_time_range()[0]
                    self.drag_tscale = self.tscale
                if not self.stuck:
                    shift_x = (x - self.press_x) / self.drag_tscale
                    t0 = max(self.drag_t0 - shift_x, 0)
                    self.set_time_range(t0, t0 + self.end - self.begin)
        except ValueError:
            pass
        return 1
    def _zoom_click(self, event, factor):
        x, y = self._itransform(event.x, event.y)
        t0, t1 = self.get_time_range()
        new_dt = (self.end - self.begin) * factor
        self.begin = max(x - new_dt * ((x - t0) / (t1 - t0)), 0)
        self.end = self.begin + new_dt
        self.plot()
    def cmd_release(self, widget, event):
        try:
            if event.button == 1 and self.press_x is not None:
                if self.press_state & gtk.gdk.CONTROL_MASK:
                    if self.press_state & gtk.gdk.MOD1_MASK:
                        self._zoom_click(event, 4)
                    else:
                        self._zoom_click(event, 0.25)
                else:
                    self.mod_state = -1 # lie
        except ValueError:
            pass
        self._state2cursor(self.canvas.window.get_pointer()[2])
        self.press_x = None
        return 1
    def _state2cursorname(self, state):
        if state < 0:
            return ""
        elif not state & gtk.gdk.CONTROL_MASK:
            return "hand"
        elif state & gtk.gdk.MOD1_MASK:
            return "zoomout"
        else:
            return "zoomin"
    def _state2cursor(self, state):
        if state & gtk.gdk.BUTTON1_MASK and not (self.press_state & gtk.gdk.CONTROL_MASK):
            pass
        else:
            s1 = self._state2cursorname(self.mod_state)
            s2 = self._state2cursorname(state)
            if s1 != s2:
                self.canvas.window.set_cursor(PlotCursors(self.canvas)[s2])
            self.mod_state = state
    def cmd_check_state(self, widget, event):
        self._state2cursor(widget.window.get_pointer()[2])
        return 1
    def cmd_check_state_focus(self, widget, event):
        self._state2cursor(widget.window.get_pointer()[2])
        self.grab_focus()
        return 1

    # drawing helpers
    def _draw_label_y(self, text, pos, edge1, edge2, drawable, gc, layout):
        if re.match(".*e\\+0[4-7]$", text):
            text = str(float(text))[:-2]
        if re.match("...*000$", text):
            text = text[:-3] + "K"
        drawable.draw_text(gc, layout, text, edge1, pos, anchor=ANCHOR_E)
    def _draw_label_x(self, text, pos, edge1, edge2, drawable, gc, layout):
        drawable.draw_text(gc, layout, text, pos, edge2, anchor=ANCHOR_N)
    def _draw_tic_x(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, pos, edge1, pos, edge1 + len)
        drawable.draw_line(gc, pos, edge2, pos, edge2 - len)
    def _draw_tic_y(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, edge1, pos, edge1 + len, pos)
        drawable.draw_line(gc, edge2, pos, edge2 - len, pos)
    def _draw_axis(self, scale, off, pos1, pos2, step, edge1, edge2, ticer, labeller, drawable, gc, playout):
        if abs(step * scale) >= 75:
            mstep = step / 10
        else:
            mstep = step / 4
        for pos in frange(floor(pos1 / step) * step, pos2, step):
            pix = pos * scale + off
            if pos >= pos1:
                ticer(pix, edge1, edge2, 5, drawable, gc)
                labeller("%g" % pos, pix, edge1, edge2, drawable, gc, playout)
            for mpos in frange(pos + mstep, min(pos + step, pos2), mstep):
                mpix = mpos * scale + off
                if mpos >= pos1:
                    ticer(mpix, edge1, edge2, 2, drawable, gc)

    def plot(self, drawable=None):
        if drawable is None: drawable = PlotCanvas_ScreenDrawable(self)
        drawable.prepare()
        drawable.clear()
        if self.conn is not None:

            # analyze time ranges
            ranges = fix_range(self.begin, self.end, 30.0 / self.plot_width)
            t0, t1, tstep = ranges["low"], ranges["high"], ranges["step"]

            # analyze sequence ranges
            s0, s1 = self.conn.get_seq_range(self.dir, t0, t1)
            if s1 <= s0: s0 = 0; s1 = 1
            ranges = fix_range(s0, s1, 30.0 / self.plot_height)
            s0, s1, sstep = ranges["low"], ranges["high"], ranges["step"]

            # get transformation
            tscale = self.plot_width / float(t1 - t0)
            sscale = self.plot_height / float(s0 - s1)
            toff = self.left_margin - (t0 * tscale)
            soff = self.top_margin - (s1 * sscale)
            self.tscale, self.sscale, self.toff, self.soff = tscale, sscale, toff, soff

            # variables
            playout = drawable.layout()
            small_playout = drawable.layout("small")

            # clear background
            drawable.fill_rectangle(drawable.gc("bg"), self.left_margin, self.top_margin, self.plot_width, self.plot_height)

            # losses
            gc = drawable.gc("lossborder")
            for l in self.conn.losses(self.dir, t0, t1):
                x0 = max(t0, l.begin) * tscale + toff
                x1 = min(t1, l.end) * tscale + toff
                y0 = max(s0, l.seq) * sscale + soff
                y1 = min(s1, l.end_seq) * sscale + soff
                gc_fg, gc_bg = drawable.gc(l.type), drawable.gc(l.type + ".bg")
                drawable.fill_rectangle(gc_bg, x0, self.top_margin, x1 - x0 + 1, self.plot_height)
                drawable.fill_rectangle(gc_fg, x0, y1, x1 - x0 + 1, y0 - y1 + 1)
                drawable.draw_rectangle(gc, x0, y1, x1 - x0 + 1, y0 - y1 + 1)
            
            # border box
            border_gc = drawable.gc("border")
            drawable.draw_rectangle(border_gc, self.left_margin, self.top_margin, self.plot_width, self.plot_height)

            # axes
            self._draw_axis(tscale, toff, t0, t1, tstep, self.top_margin, self.wheight - self.bottom_margin, self._draw_tic_x, self._draw_label_x, drawable, border_gc, playout)
            self._draw_axis(sscale, soff, s0, s1, sstep, self.left_margin, self.wwidth - self.right_margin, self._draw_tic_y, self._draw_label_y, drawable, border_gc, playout)
            
            # data packets
            gc = drawable.gc("data")
            for p in self.conn.packets(self.dir, t0, t1):
                x, y, yy = p.time * tscale + toff, p.seq * sscale + soff, p.last_seq * sscale + soff
                drawable.draw_line(gc, x - 2, y, x + 3, y)
                drawable.draw_line(gc, x - 2, yy, x + 3, yy)
                drawable.draw_line(gc, x, y, x, yy)
            
            # ack packets
            gc1, gc2 = drawable.gc("ack"), drawable.gc("dataack")
            last_dupack, last_dupack_x = -1, None
            for p in self.conn.rev_packets(1 - self.dir, t0, t1):
                x, y = int(floor(p.time * tscale + toff)), int(floor(p.ack * sscale + soff))
                if p.dup_acks > 0 and (p.ack != last_dupack or x < last_dupack_x):
                    text = str(p.dup_acks + 1)
                    extents = drawable.text_extents(small_playout, text, x, y, anchor=ANCHOR_N)
                    if p.ack != last_dupack or extents[2] < last_dupack_x:
                        drawable.draw_text(border_gc, small_playout, text, x, y, anchor=ANCHOR_N)
                        last_dupack = p.ack
                        last_dupack_x = extents[0] - 4
                if p.pure_ack():
                    drawable.draw_line(gc1, x - 2, y - 2, x + 2, y + 2)
                    drawable.draw_line(gc1, x - 2, y + 2, x + 2, y - 2)
                else:
                    drawable.draw_line(gc2, x - 2, y - 2, x + 2, y + 2)
                    drawable.draw_line(gc2, x - 2, y + 2, x + 2, y - 2)

            self.plotted = True

        else:
            self.plotted = False


class PlotBox:
    def __init__(self, master):
        self.frame = gtk.VBox()
        master.pack_start(self.frame, expand=1, fill=1)
        self.frame.show()
        
        self.lframe = gtk.HBox()
        self.frame.pack_start(self.lframe, expand=0, fill=0)
        self.lframe.show()
        self.l0 = gtk.Label("")
        self.dirbutton = gtk.Button(">")
        self.dirbutton.connect("clicked", self.cmd_dirbutton)
        self.dirbutton.unset_flags(gtk.CAN_FOCUS)
        self.l1 = gtk.Label("foo")
        self.lframe.pack_start(self.l0, expand=0, fill=0); self.l0.show()
        self.lframe.pack_start(self.dirbutton, expand=0, fill=0); self.dirbutton.show()
        self.lframe.pack_start(self.l1, expand=0, fill=0); self.l1.show()
        
        self.canvas = PlotCanvas(self.frame)
    def cmd_dirbutton(self, *args):
        self.set_flowref(self.canvas.get_flowref().opposite())
    def set_flowref(self, fref):
        self.canvas.set_flowref(fref)
        desc = fref.conn.get_description()
        mid = desc.find(' > ')
        s = desc[:mid + 1]
        s = re.sub("(^\\#[0-9]+)", "  <b>\\1</b>", s)
        self.l0.set_markup(s)
        self.l1.set_label(desc[mid + 2:])
        self.dirbutton.set_label("><"[fref.dir])
    def set_time_range(self, begin, end):
        self.canvas.set_time_range(begin, end)
    def zoom_in(self):
        t0, t1 = self.canvas.get_time_range()
        self.canvas.set_time_range(0.667*t0 + 0.333*t1, 0.333*t0 + 0.667*t1)
    def pack(self, *args, **keys):
        self.frame.pack(*args, **keys)


class FlowTree:
    def __init__(self, parent, fset, plotbox=None):
        scrolled_window = gtk.ScrolledWindow()
        scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        parent.add(scrolled_window)

        self.model = FlowSetTreeModelByLosses(fset)
        self.treeview = gtk.TreeView(self.model)
        self.treeview.set_headers_visible(gtk.FALSE)
        cell1 = gtk.CellRendererText()
        # the text in the column comes from column 0
        column = gtk.TreeViewColumn("tuples", cell1, text=0)
        self.treeview.append_column(column)
        column = gtk.TreeViewColumn("tuples", cell1, text=1)
        self.treeview.append_column(column)
        column = gtk.TreeViewColumn("tuples", cell1, text=2)
        self.treeview.append_column(column)
        column = gtk.TreeViewColumn("tuples", cell1, text=3)
        self.treeview.append_column(column)
        self.treeview.show()

        scrolled_window.add(self.treeview)
        scrolled_window.show()

        self.plotbox = plotbox
        if self.plotbox is not None:
            self.treeview.connect("row_activated", self.cmd_row_activated)

    def select_flowref(self, fref):
        #self.model.flowref_changed(fref) 
        pass

    def cmd_row_activated(self, widget, path, column):
        fref = self.model.path2flowref(path)
        self.plotbox.set_flowref(fref)
        self.select_flowref(fref)


class PlotFlowWindow:
    def __init__(self, fset):
        self.flowset = fset
        self.flowid = 0
        
        win = gtk.Window()
        win.connect('destroy', self.cmd_exit)
        win.set_title("PlotFlow")

        vbox = gtk.VBox()
        win.add(vbox)
        vbox.show()

        self._init_menus(win, vbox)
        self.plotbox = PlotBox(vbox)

        self.flowtree = FlowTree(vbox, fset, self.plotbox)

        if len(fset):
            self.plotbox.set_flowref(fset[0])
            self.flowtree.select_flowref(fset[0])

        win.show()

        self.plotbox.canvas.grab_focus()

    def _init_menus(self, win, vbox):
        accel_group = gtk.AccelGroup()
        self.item_factory = gtk.ItemFactory(gtk.MenuBar, "<main>", accel_group)
        win.add_accel_group(accel_group)
        self.item_factory.create_items((
            ( "/_File",         None,         None, 0, "<Branch>" ),
   	    ( "/File/_Open",    "<control>O", None, 0, None ),
   	    ( "/File/_Save",    "<control>S", None, 0, None ),
   	    ( "/File/Save _As", None,         None, 0, None ),
   	    ( "/File/sep1",     None,         None, 0, "<Separator>" ),
   	    ( "/File/Quit",     "<control>Q", self.cmd_exit, 0, None ),
            ( "/_View",		None,		None, 0, "<Branch>" ),
            ( "/View/_Zoom In",	"<control>equal", self.cmd_zoom_in, 0, None ),
            ( "/View/Zoom _Out", "<control>minus", self.cmd_zoom_out, 0, None ),
   	    ( "/View/sep1",     None,         None, 0, "<Separator>" ),
            ( "/View/_Next Flow", "<control>Right", self.cmd_next_flow, 0, None ),
            ( "/View/_Previous Flow", "<control>Left", self.cmd_prev_flow, 0, None ),
   	    ))
        self._activate_flow_items()
        menubar = self.item_factory.get_widget("<main>")
        vbox.pack_start(menubar, 0, 0)
        menubar.show()

    def cmd_exit(self, *args):
        gtk.main_quit()

    def cmd_zoom_in(self, widget, event):
        self.plotbox.zoom_in()

    def cmd_zoom_out(self, widget, event):
        self.plotbox.set_time_range(None, None)

    def _activate_flow_items(self):
        self.item_factory.get_item("/View/Next Flow").set_sensitive(self.flowid < len(self.flowset) - 1)
        self.item_factory.get_item("/View/Previous Flow").set_sensitive(self.flowid > 0)

    def _change_flowid(self, new_flowid):
        of, nf = self.flowset[self.flowid], self.flowset[new_flowid]
        if of.conn is not nf.conn:
            of.unload()
        self.plotbox.set_flowref(nf)
        self.flowtree.select_flowref(nf)
        self.flowid = new_flowid
        self._activate_flow_items()
    
    def cmd_next_flow(self, widget, event):
        self._change_flowid(self.flowid + 1)

    def cmd_prev_flow(self, widget, event):
        self._change_flowid(self.flowid - 1)


if __name__ == "__main__":
    all_connections = FlowSet()
    try:
        if len(sys.argv) >= 2:
            f = uncompressed_file(sys.argv[1])
            c = f.read(1)
            f.seek(0)
            if c == '<':
                all_connections.read(f)
            else:
                all_connections.append(Connection(sys.argv[1]))
        else:
            all_connections.append(Connection(sys.stdin))
        all_connections.sort_by_loss_count()
        print all_connections.sum_loss_count
        window = PlotFlowWindow(all_connections)
        gtk.main()
    except KeyboardInterrupt:
        gtk.main_quit()

# 1752 >
# 1
