#!/usr/bin/env python

from __future__ import generators
from bisect import bisect
import sys, re, types, string, struct, gzip
from math import *
import gtk, pango

fill_colors = {
    "data": "red", "ack": "green", "dataack": "blue",
    "loss": ("gold", "khaki"), "ploss": ("mint cream", "mint cream"), "floss": ("grey80", "grey90"),
    "border": "dark grey", "lossborder": "yellow"
}
gc_dashes = {
    "lossborder": [4, 4]
}


def frange(start, stop, step):
    i = 0
    while True:
        pos = start + i * step
        if pos > stop:
            break
        yield pos
        i += 1

class Packet:
    def __init__(self, time, flags, seq, payloadlen, ack, dup_acks=0):
        self.time = float(time)
        self.seq = int(seq)
        self.last_seq = self.seq + int(payloadlen)
        self.ack = int(ack)
        if flags != "A" and flags != "AU":
            if flags.find("S") or flags.find("F"):
                self.last_seq += 1
        self.dup_acks = int(dup_acks)
    def pure_ack(self):
        return self.seq == self.last_seq
    def has_data(self):
        return self.seq != self.last_seq
    def __cmp__(self, other):
        return self.time.__cmp__(other.time)
    def __str__(self):
        result = "[" + str(self.time) + " "
        if self.pure_ack():
            result += "A" + str(self.ack)
        else:
            result += str(self.seq) + ":" + str(self.last_seq)
        return result + "]"

class LossEvent:
    def __init__(self, type, begin, seq, end, end_seq):
        self.type, self.begin, self.seq, self.end, self.end_seq = \
                   type, float(begin), int(seq), float(end), int(end_seq)
    def time_overlaps(self, begin, end):
        return (begin is None or self.end >= begin) and (end is None or end >= self.begin);
    def fillcolor(self):
        return fill_colors[self.type]


class ConnectionFormatError(Exception):
    def __init__(self, s=""):
        self.str = s
    def __str__(self):
        return `self.str`
class ConnectionFileCompressedError(ConnectionFormatError):
    def __init__(self, s=""):
        self.str = s
    def __str__(self):
        return `self.str`

def direction(dir):
    if dir == '>':
        return 0
    elif dir == '<':
        return 1
    elif dir is True:
        return 0
    elif dir is False:
        return 1
    elif int(dir) == 0 or int(dir) == 1:
        return int(dir)
    else:
        raise ConnectionFormatError, "bad direction " + `dir`


def unparse_tcp_flags(flags):
    return ("", "F", "S", "FS", "R", "FR", "SR", "FSR",
            "P", "FP", "SP", "FSP", "RP", "FRP", "SRP", "FSRP")[flags & 15] \
        + ("", "A", "U", "AU", "E", "AE", "UE", "AUE",
           "W", "AW", "UW", "AUW", "EW", "AEW", "UEW", "AUEW")[(flags >> 4) & 15]

class Connection:
    
    def __init__(self, f=None):
        self.s = ([], [])
        self.loss = ([], [])
        self.flow_id = []
        self.aggregate = -1
        self.available = False
        if type(f) == types.FileType:
            self.read(f)
        else:
            self.filename = f

    class Fileboy:
        def __init__(self, f):
            self.f = f
            self.str = ""
            self.pos = 0
        def __iter__(self):
            return self
        def next(self):
            try:
                eol = self.str.find("\n", self.pos)
                while eol < 0:
                    if self.pos > 0:
                        self.str = self.str[self.pos:]
                        self.pos = 0
                    p = len(self.str)
                    self.str += self.f.read(32768)
                    eol = self.str.find("\n", p)
                p = self.pos
                self.pos = eol + 1
                return self.str[p:eol + 1]
            except EOFError:
                raise StopIteration
        def read(self):
            return self.str[self.pos:] + self.f.read()
    
    def _check_data(self):
        if self.read_state == "a":      # ASCII
            x = '!data timestamp direction tcp_flags tcp_seq payload_len tcp_ack'
        elif self.read_state == "b":    # binary
            x = '!data timestamp tcp_seq payload_len tcp_ack tcp_flags direction'
        else:
            return
        if not re.match(x, self.read_data):
            raise ConnectionFormatError, "bad !data"
    
    def _read_nonpacket(self, line):
        if re.match('\\#[pf]?loss', line):
            type, dir, time, seq, end_time, end_seq = line[1:].split()[:6]
            self.loss[direction(dir)].append(LossEvent(type, time, seq, end_time, end_seq))
        elif re.match('!flowid', line):
            self.flow_id = line.split()[1:]
        elif re.match('!aggregate', line):
            self.aggregate = int(line.split()[1])
        elif re.match('!data ', line):
            self.read_data = line
            self._check_data()
        elif re.match('!eof$', line):
            return 1
        elif line[:2] == "\037\235" or line[:2] == "\037\213": # compressed data
            raise ConnectionFileCompressedError
        return 0

    def _read_binary(self, f):
        self.read_state = "b"
        self._check_data()

        last_ack = [-1, -1]; dup_acks = [0, 0]
        data = f.read()
        while len(data) > 4:
            l, = struct.unpack("!l", data[:4])
            i = l & 0x7FFFFFFF
            line, data = data[4:i], data[i:]
            if len(line) < i - 4:
                raise ConnectionFormatError, "corrupted file"
            elif l & 0x80000000:
                if self._read_nonpacket(line):
                    break
            elif i >= 26:
                ts_sec, ts_usec, seq, payloadlen, ack, flags, dir = \
                   struct.unpack("!lllllBB", line[:26])
                time = ts_sec + ts_usec / 1000000.
                if flags == 16: flags = "A"
                else: flags = unparse_tcp_flags(flags)
                if ack == last_ack[dir]: dup_acks[dir] += 1
                else: dup_acks[dir] = 0; last_ack[dir] = ack
                self.s[dir].append(Packet(time, flags, seq, payloadlen, ack, dup_acks[dir]))

    def read(self, f):
        last_ack = [-1, -1]; dup_acks = [0, 0]
        read_state = 0; self.read_state = ""; self.read_data = ""
        f = Connection.Fileboy(f)
        for line in f:
            if line and line[0] >= '0' and line[0] <= '9':
                if read_state == 0:
                    read_state = 1; self.read_state = "a"
                    self._check_data()
                time, dir, flags, seq, payloadlen, ack = line.split()
                dir, ack = direction(dir), int(ack)
                if ack == last_ack[dir]: dup_acks[dir] += 1
                else: dup_acks[dir] = 0; last_ack[dir] = ack
                self.s[dir].append(Packet(time, flags, seq, payloadlen, ack, dup_acks[dir]))
            elif re.match('!binary', line):
                self.read_state = "b"
                break
            elif self._read_nonpacket(line):
                break
        if self.read_state == "b":
            self._read_binary(f)
        self.available = True
        del self.read_state
        del self.read_data
        return self
    
    def first_index_after(self, time, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            return self.first_index_after(time, 0), self.first_index_after(time, 1)
        else:
            fake_pkt = Packet(time, "A", 0, 0, 0)
            return bisect(self.s[direction(dir)], fake_pkt)
    
    def packets(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        if begin is None:
            i = 0
        else:
            i = self.first_index_after(begin, dir)
        while i < len(self.s[dir]) and (end is None or self.s[dir][i].time <= end):
            yield self.s[dir][i]
            i += 1
    
    def rev_packets(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        if end is None:
            i = len(self.s[dir]) - 1
        else:
            i = self.first_index_after(end, dir) - 1
        while i >= 0 and (begin is None or self.s[dir][i].time >= begin):
            yield self.s[dir][i]
            i -= 1
    
    def losses(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        for l in self.loss[dir]:
            if l.time_overlaps(begin, end):
                yield l
    
    def get_time_range(self, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            return min(self.s[0][0].time, self.s[1][0].time), max(self.s[0][-1].time, self.s[1][-1].time)
        else:
            dir = direction(dir)
            return self.s[dir][0].time, self.s[dir][-1].time
    
    def _time_index(self, dir, time, after):
        if time is not None:
            return self.first_index_after(time, dir)
        elif after:
            return len(self.s[dir])
        else:
            return 0
    
    def _seq_range(self, dir, begin, end):
        s0, s1 = 1e10, None
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].seq - 10)
            s1 = max(s1, self.s[dir][i].last_seq + 10)
        for l in self.losses(dir, begin, end):
            s0 = min(s0, l.seq - 10)
            s1 = max(s1, l.end_seq + 10)
        return max(s0, 0), s1
    
    def _ack_range(self, dir, begin, end):
        s0, s1 = 1e10, None
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].ack - 10)
            s1 = max(s1, self.s[dir][i].ack + 10)
        return max(s0, 0), s1
    
    def seq_range(self, dir=None, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        r0, r1 = self._seq_range(dir, begin, end), self._ack_range(1 - dir, begin, end)
        return min(r0[0], r1[0]), max(r0[1], r1[1])
    
    def get_description(self):
        if not self.available:
            self.load()
        s = ""
        if self.aggregate >= 0:
            s += "#" + `self.aggregate` + ": "
        return s + self.flow_id[0] + ":" + self.flow_id[1] + " > " + self.flow_id[2] + ":" + self.flow_id[3]
    
    def load(self):
        if type(self.filename) != types.StringType:
            raise RuntimeError, "cannot load this Connection"
        elif not self.available:
            f = file(self.filename, 'rb')
            try:
                self.read(f)
            except ConnectionFileCompressedError:
                f.seek(0)
                self.read(gzip.GzipFile(fileobj=f))
            f.close()
    
    def unload(self):
        if type(self.filename) == types.StringType:
            self.__init__(self.filename)


def fix_range(a, b, min_step_frac):
    d = b - a
    step = 10 ** floor(log10(d))

    # make step bigger if required
    if step / d > 0.5 and step / d >= min_step_frac:
        if step/5 / d >= min_step_frac:
            step /= 5
        elif step/2.5 / d >= min_step_frac:
            step /= 2.5
        elif step/2 / d >= min_step_frac:
            step /= 2
    while step < d and step / d < min_step_frac:
        if 2*step / d >= min_step_frac:
            step *= 2
        elif 2.5*step / d >= min_step_frac:
            step *= 2.5
        elif 5*step / d >= min_step_frac:
            step *= 5
        else:
            step *= 10
    if step >= d:
        step = d

    # bound a and b to multiples of step, if appropriate
    a_try = floor(a / step) * step
    if a - a_try < 0.1*d:
        a = a_try; d = b - a
    b_try = ceil(b / step) * step
    if b_try - b < 0.1*d:
        b = b_try
    
    # return a dictionary
    return { "low": a, "high": b, "step": step }


_plot_cursors = {
    "zoomin": ("zoomin_data", "zoom_mask", 6, 6),
    "zoomout": ("zoomout_data", "zoom_mask", 6, 6),
    "hand": ("hand_data", "hand_mask", 9, 8),
    "grabhand": ("grabhand_data", "grabhand_mask", 8, 7),
    "zoomin_data": (string.join(map(chr, [
	0xf0, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x04, 0x00, 0x62, 0x04, 0x00,
        0x61, 0x08, 0x00, 0xf9, 0x09, 0x00, 0xf9, 0x09, 0x00, 0x61, 0x08, 0x00,
        0x62, 0x04, 0x00, 0x02, 0x04, 0x00, 0x0c, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00 ]), ''), 17, 17),
    "zoomout_data": (string.join(map(chr, [
	0xf0, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x02, 0x04, 0x00, 0x02, 0x04, 0x00,
        0x01, 0x08, 0x00, 0xf9, 0x09, 0x00, 0xf9, 0x09, 0x00, 0x01, 0x08, 0x00,
        0x02, 0x04, 0x00, 0x02, 0x04, 0x00, 0x0c, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00 ]), ''), 17, 17),
    "zoom_mask": (string.join(map(chr, [
        0xf0, 0x00, 0x00, 0xfc, 0x03, 0x00, 0xfe, 0x07, 0x00, 0xfe, 0x07, 0x00,
        0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x0f, 0x00,
        0xfe, 0x07, 0x00, 0xfe, 0x07, 0x00, 0xfc, 0x0f, 0x00, 0xf0, 0x1c, 0x00,
        0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xc0, 0x01,
        0x00, 0x80, 0x00]), ''), 17, 17),
    "hand_data": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x1c, 0x00, 0xc8, 0x24, 0x00,
        0xc8, 0xa4, 0x00, 0x90, 0x64, 0x01, 0x90, 0x24, 0x01, 0x2c, 0x20, 0x01,
        0x32, 0x00, 0x01, 0x22, 0x80, 0x00, 0x04, 0x80, 0x00, 0x08, 0x80, 0x00,
        0x08, 0x40, 0x00, 0x10, 0x40, 0x00, 0x20, 0x20, 0x00, 0x40, 0x20, 0x00,
        0x40, 0x20, 0x00, 0x00, 0x00, 0x00]), ''), 18, 18),
    "hand_mask": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xb0, 0x1f, 0x00, 0xf8, 0x3f, 0x00,
        0xf8, 0xbf, 0x00, 0xf0, 0xff, 0x01, 0xf0, 0xff, 0x01, 0xec, 0xff, 0x01,
        0xfe, 0xff, 0x01, 0xfe, 0xff, 0x00, 0xfc, 0xff, 0x00, 0xf8, 0xff, 0x00,
        0xf8, 0x7f, 0x00, 0xf0, 0x7f, 0x00, 0xe0, 0x3f, 0x00, 0xc0, 0x3f, 0x00,
        0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00]), ''), 18, 18),
    "grabhand_data": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0d, 0x48, 0x12,
        0x08, 0x30, 0x0c, 0x40, 0x0a, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x20,
        0x04, 0x20, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10]), ''), 16, 16),
    "grabhand_mask": (string.join(map(chr, [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0d, 0xf8, 0x1f,
        0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x3f,
        0xfc, 0x3f, 0xf8, 0x1f, 0xf0, 0x1f, 0xf0, 0x1f]), ''), 16, 16)
    }
class PlotCursors:
    def __init__(self, win):
        self.window = win
    def make_pixmap(self, name):
        if name + ".pix" not in _plot_cursors:
            l = _plot_cursors[name]
            _plot_cursors[name + ".pix"] = gtk.gdk.bitmap_create_from_data(self.window.window, l[0], l[1], l[2])
    def __getitem__(self, name):
        if name + ".cur" not in _plot_cursors:
            data, mask, hotx, hoty = _plot_cursors[name]
            self.make_pixmap(data)
            self.make_pixmap(mask)
            black = self.window.get_style().black
            white = self.window.get_style().white
            _plot_cursors[name + ".cur"] = gtk.gdk.Cursor(_plot_cursors[data + ".pix"], _plot_cursors[mask + ".pix"], black, white, hotx, hoty)
        return _plot_cursors[name + ".cur"]


class PlotCanvas:

    # initialization
    def __init__(self, master, width=600, height=500):
        self.canvas = gtk.DrawingArea()
        self.canvas.set_size_request(width, height)
        self.canvas.set_flags(gtk.CAN_FOCUS)

        self.canvas.connect("configure_event", self.cmd_configure)
        self.canvas.connect("expose_event", self.cmd_expose)
        self.canvas.connect("button_press_event", self.cmd_press)
        self.canvas.connect("motion_notify_event", self.cmd_motion)
        self.canvas.connect("button_release_event", self.cmd_release)
        self.canvas.connect("key_press_event", self.cmd_check_state)
        self.canvas.connect("key_release_event", self.cmd_check_state)
        self.canvas.connect("enter_notify_event", self.cmd_check_state)
        self.canvas.set_events(gtk.gdk.EXPOSURE_MASK | gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK | gtk.gdk.ENTER_NOTIFY_MASK | gtk.gdk.LEAVE_NOTIFY_MASK | gtk.gdk.KEY_PRESS_MASK | gtk.gdk.KEY_RELEASE_MASK | gtk.gdk.BUTTON1_MOTION_MASK | gtk.gdk.POINTER_MOTION_HINT_MASK)
        
        master.pack_start(self.canvas, expand=1, fill=1)
        self.canvas.show()

        self.left_margin = 40
        self.right_margin = 20
        self.top_margin = 10
        self.bottom_margin = 20
        self.gc = {}
        self.plotted = False
        self.press_x = None
        self.mod_state = 0

    # getting properties
    def get_connection(self):
        return self.conn
    def get_direction(self):
        return self.dir
    def get_time_range(self):
        if self.plotted:
            return (self.left_margin - self.toff) / self.tscale, (self.left_margin + self.plot_width - self.toff) / self.tscale
        else:
            return self.begin, self.end

    # setting properties
    def set_connection(self, conn, dir, begin=None, end=None):
        self.conn, self.dir = conn, direction(dir)
        self.set_time_range(begin, end)
    def set_direction(self, dir):
        self.dir = direction(dir)
        if self.plotted: self.plot()
    def set_time_range(self, begin, end):
        if begin is None: begin = self.conn.get_time_range()[0]
        if end is None: end = self.conn.get_time_range()[1]
        self.begin, self.end = begin, end
        if self.plotted: self.plot()

    def cmd_configure(self, widget, event):
        x, y, self.wwidth, self.wheight = widget.get_allocation()

        if not self.gc.has_key("data"):
            cmap = self.canvas.get_colormap()
            for k in fill_colors.keys():
                v = fill_colors[k]
                if type(v) == types.TupleType:
                    self.gc[k] = (self.canvas.window.new_gc(foreground=cmap.alloc_color(v[0]), line_width=0, cap_style=gtk.gdk.CAP_BUTT),
                                  self.canvas.window.new_gc(foreground=cmap.alloc_color(v[1]), line_width=0, cap_style=gtk.gdk.CAP_BUTT))
                else:
                    self.gc[k] = self.canvas.window.new_gc(foreground=cmap.alloc_color(v), line_width=0, cap_style=gtk.gdk.CAP_BUTT)
            for k in gc_dashes.keys():
                self.gc[k].line_style = gtk.gdk.LINE_ON_OFF_DASH
                self.gc[k].set_dashes(0, gc_dashes[k])
            self.canvas.window.set_cursor(PlotCursors(self.canvas)["hand"])
        
        self.plot_width = self.wwidth - self.left_margin - self.right_margin
        self.plot_height = self.wheight - self.top_margin - self.bottom_margin
    def cmd_expose(self, widget, event):
        self.plot()

    def _itransform(self, x, y, constrain=True):
        if self.plotted and (not constrain or (x >= self.left_margin and x <= self.left_margin + self.plot_width and y >= self.top_margin and y <= self.top_margin + self.plot_height)):
            return (x - self.toff) / self.tscale, (y - self.soff) / self.sscale
        else:
            raise ValueError
    def cmd_press(self, widget, event):
        try:
            if event.button == 1:
                self._itransform(event.x, event.y) # for signal
                self.press_x = event.x
                if not (event.state & (gtk.gdk.CONTROL_MASK | gtk.gdk.SHIFT_MASK)):
                    self.canvas.window.set_cursor(PlotCursors(self.canvas)["grabhand"])
        except ValueError:
            pass
        self.stuck = True
        self.press_state = event.state
        return 1
    def cmd_motion(self, widget, event):
        try:
            x, y, state = widget.window.get_pointer()
            if (state & gtk.gdk.BUTTON1_MASK) and self.plotted:
                if self.stuck and (abs(self.press_x - x) > 5):
                    self.stuck = False
                    self.drag_t0 = self.get_time_range()[0]
                    self.drag_tscale = self.tscale
                if not self.stuck:
                    shift_x = (x - self.press_x) / self.drag_tscale
                    t0 = max(self.drag_t0 - shift_x, 0)
                    self.set_time_range(t0, t0 + self.end - self.begin)
        except ValueError:
            pass
        return 1
    def _zoom_click(self, event, factor):
        x, y = self._itransform(event.x, event.y)
        t0, t1 = self.get_time_range()
        new_dt = (self.end - self.begin) * factor
        self.begin = max(x - new_dt * ((x - t0) / (t1 - t0)), 0)
        self.end = self.begin + new_dt
        self.plot()
    def cmd_release(self, widget, event):
        try:
            if event.button == 1 and self.press_x is not None:
                if self.press_state & gtk.gdk.SHIFT_MASK:
                    self._zoom_click(event, 0.25)
                elif self.press_state & gtk.gdk.CONTROL_MASK:
                    self._zoom_click(event, 4)
                else:
                    self.mod_state = gtk.gdk.CONTROL_MASK # lie
        except ValueError:
            pass
        self._state2cursor(self.canvas.window.get_pointer()[2])
        self.press_x = None
        return 1
    def _state2cursor(self, state):
        if state & gtk.gdk.BUTTON1_MASK:
            pass
        elif (state & gtk.gdk.SHIFT_MASK) and not (self.mod_state & gtk.gdk.SHIFT_MASK):
            self.canvas.window.set_cursor(PlotCursors(self.canvas)["zoomin"])
        elif (state & gtk.gdk.CONTROL_MASK) and not (self.mod_state & gtk.gdk.CONTROL_MASK):
            self.canvas.window.set_cursor(PlotCursors(self.canvas)["zoomout"])
        elif not (state & (gtk.gdk.SHIFT_MASK|gtk.gdk.CONTROL_MASK)) and (self.mod_state & (gtk.gdk.SHIFT_MASK|gtk.gdk.CONTROL_MASK)):
            self.canvas.window.set_cursor(PlotCursors(self.canvas)["hand"])
        self.mod_state = state
    def cmd_check_state(self, widget, event):
        self._state2cursor(widget.window.get_pointer()[2])
        return 1

    # drawing helpers
    def _draw_label_y(self, text, pos, edge1, edge2, drawable, gc, playout):
        if re.match(".*e\\+0[4-7]$", text):
            text = str(float(text))[:-2]
        if re.match("...*000$", text):
            text = text[:-3] + "K"
        playout.set_text(text, -1)
        ir, lr = playout.get_extents()
        drawable.draw_layout(gc, edge1 - 4 - lr[2]/1024.0, pos - lr[3]/2048.0, playout)
    def _draw_label_x(self, text, pos, edge1, edge2, drawable, gc, playout):
        playout.set_text(text, -1)
        ir, lr = playout.get_extents()
        drawable.draw_layout(gc, pos - lr[2]/2048.0, edge2 + 2, playout)
    def _draw_tic_x(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, pos, edge1, pos, edge1 + len)
        drawable.draw_line(gc, pos, edge2, pos, edge2 - len)
    def _draw_tic_y(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, edge1, pos, edge1 + len, pos)
        drawable.draw_line(gc, edge2, pos, edge2 - len, pos)
    def _draw_axis(self, scale, off, pos1, pos2, step, edge1, edge2, ticer, labeller, drawable, gc, playout):
        if abs(step * scale) >= 75:
            mstep = step / 10
        else:
            mstep = step / 4
        for pos in frange(floor(pos1 / step) * step, pos2, step):
            pix = pos * scale + off
            if pos >= pos1:
                ticer(pix, edge1, edge2, 5, drawable, gc)
                labeller("%g" % pos, pix, edge1, edge2, drawable, gc, playout)
            for mpos in frange(pos + mstep, min(pos + step, pos2), mstep):
                mpix = mpos * scale + off
                if mpos >= pos1:
                    ticer(mpix, edge1, edge2, 2, drawable, gc)

    def plot(self, drawable=None):
        if drawable is None: drawable = self.canvas.window
        drawable.clear()
        if self.conn is not None:

            # analyze time ranges
            ranges = fix_range(self.begin, self.end, 30.0 / self.plot_width)
            t0, t1, tstep = ranges["low"], ranges["high"], ranges["step"]

            # analyze sequence ranges
            s0, s1 = self.conn.seq_range(self.dir, t0, t1)
            if s0 is None or s1 is None:
                s0 = 0; s1 = 1
            ranges = fix_range(s0, s1, 30.0 / self.plot_height)
            s0, s1, sstep = ranges["low"], ranges["high"], ranges["step"]
            
            # get transformation
            tscale = self.plot_width / float(t1 - t0)
            sscale = self.plot_height / float(s0 - s1)
            toff = self.left_margin - (t0 * tscale)
            soff = self.top_margin - (s1 * sscale)
            self.tscale, self.sscale, self.toff, self.soff = tscale, sscale, toff, soff

            # variables
            playout = self.canvas.create_pango_layout("")
            new_pcontext = self.canvas.create_pango_context()
            new_pfontdesc = new_pcontext.get_font_description().copy()
            new_pfontdesc.set_size(new_pfontdesc.get_size() * 0.75)
            new_pcontext.set_font_description(new_pfontdesc)
            small_playout = pango.Layout(new_pcontext)

            # clear background
            drawable.draw_rectangle(self.canvas.get_style().white_gc, gtk.TRUE, self.left_margin, self.top_margin, self.plot_width, self.plot_height)

            # losses
            gc = self.gc["lossborder"]
            for l in self.conn.losses(self.dir, t0, t1):
                x0 = max(t0, l.begin) * tscale + toff
                x1 = min(t1, l.end) * tscale + toff
                y0 = max(s0, l.seq) * sscale + soff
                y1 = min(s1, l.end_seq) * sscale + soff
                gc1 = self.gc[l.type]
                drawable.draw_rectangle(gc1[1], gtk.TRUE, x0, self.top_margin, x1 - x0 + 1, self.plot_height)
                drawable.draw_rectangle(gc1[0], gtk.TRUE, x0, y1, x1 - x0 + 1, y0 - y1 + 1)
                drawable.draw_rectangle(gc, gtk.FALSE, x0, y1, x1 - x0 + 1, y0 - y1 + 1)
            
            # border box
            gc = self.gc["border"]
            drawable.draw_rectangle(gc, gtk.FALSE, self.left_margin, self.top_margin, self.plot_width, self.plot_height)

            # axes
            self._draw_axis(tscale, toff, t0, t1, tstep, self.top_margin, self.wheight - self.bottom_margin, self._draw_tic_x, self._draw_label_x, drawable, gc, playout)
            self._draw_axis(sscale, soff, s0, s1, sstep, self.left_margin, self.wwidth - self.right_margin, self._draw_tic_y, self._draw_label_y, drawable, gc, playout)
            
            # data packets
            gc = self.gc["data"]
            for p in self.conn.packets(self.dir, t0, t1):
                x, y, yy = p.time * tscale + toff, p.seq * sscale + soff, p.last_seq * sscale + soff
                drawable.draw_line(gc, x - 2, y, x + 3, y)
                drawable.draw_line(gc, x - 2, yy, x + 3, yy)
                drawable.draw_line(gc, x, y, x, yy)
            
            # ack packets
            gc, gc1, gc2 = self.gc["border"], self.gc["ack"], self.gc["dataack"]
            last_dupack, last_dupack_x = -1, None
            for p in self.conn.rev_packets(1 - self.dir, t0, t1):
                x, y = int(floor(p.time * tscale + toff)), int(floor(p.ack * sscale + soff))
                if p.dup_acks > 0 and (p.ack != last_dupack or x < last_dupack_x):
                    small_playout.set_text(str(p.dup_acks + 1), -1)
                    ir, lr = small_playout.get_extents()
                    if p.ack != last_dupack or x + lr[2]/2048.0 < last_dupack_x:
                        drawable.draw_layout(gc, x - lr[2]/2048.0, y + 2, small_playout)
                        last_dupack = p.ack
                        last_dupack_x = x - lr[2]/2048.0 - 4
                if p.pure_ack():
                    drawable.draw_line(gc1, x - 2, y - 2, x + 2, y + 2)
                    drawable.draw_line(gc1, x - 2, y + 2, x + 2, y - 2)
                else:
                    drawable.draw_line(gc2, x - 2, y - 2, x + 2, y + 2)
                    drawable.draw_line(gc2, x - 2, y + 2, x + 2, y - 2)

            self.plotted = True

        else:
            self.plotted = False


class PlotBox:
    def __init__(self, master):
        self.frame = gtk.VBox()
        master.pack_start(self.frame, expand=1, fill=1)
        self.frame.show()
        
        self.lframe = gtk.HBox()
        self.frame.pack_start(self.lframe, expand=0, fill=0)
        self.lframe.show()
        self.l0 = gtk.Label("")
        self.dirbutton = gtk.Button(">")
        self.dirbutton.connect("clicked", self.cmd_dirbutton)
        self.dirbutton.unset_flags(gtk.CAN_FOCUS)
        self.l1 = gtk.Label("foo")
        self.lframe.pack_start(self.l0, expand=0, fill=0); self.l0.show()
        self.lframe.pack_start(self.dirbutton, expand=0, fill=0); self.dirbutton.show()
        self.lframe.pack_start(self.l1, expand=0, fill=0); self.l1.show()
        
        self.canvas = PlotCanvas(self.frame)
    def cmd_dirbutton(self, *args):
        self.set_connection(self.canvas.get_connection(), 1 - self.canvas.get_direction())
    def set_connection(self, conn, dir=0):
        self.canvas.set_connection(conn, dir)
        desc = conn.get_description()
        mid = desc.find(' > ')
        s = desc[:mid + 1]
        s = re.sub("(^\\#[0-9]+)", "  <b>\\1</b>", s)
        self.l0.set_markup(s)
        self.l1.set_label(desc[mid + 2:])
        self.dirbutton.set_label("><"[self.canvas.get_direction()])
    def set_time_range(self, begin, end):
        self.canvas.set_time_range(begin, end)
    def zoom_in(self):
        t0, t1 = self.canvas.get_time_range()
        self.canvas.set_time_range(0.667*t0 + 0.333*t1, 0.333*t0 + 0.667*t1)
    def pack(self, *args, **keys):
        self.frame.pack(*args, **keys)


class PlotFlowWindow:
    def __init__(self, f):
        win = gtk.Window()
        win.connect('destroy', self.cmd_exit)
        win.set_title("PlotFlow")

        vbox = gtk.VBox()
        win.add(vbox)
        vbox.show()

        self._init_menus(win, vbox)
        self.plotbox = PlotBox(vbox)

        c = Connection(f)
        self.plotbox.set_connection(c, '<')

        win.show()

        self.plotbox.canvas.canvas.grab_focus()

    def _init_menus(self, win, vbox):
        accel_group = gtk.AccelGroup()
        self.item_factory = gtk.ItemFactory(gtk.MenuBar, "<main>", accel_group)
        win.add_accel_group(accel_group)
        self.item_factory.create_items((
            ( "/_File",         None,         None, 0, "<Branch>" ),
   	    ( "/File/_New",     "<control>N", None, 0, None ),
   	    ( "/File/_Open",    "<control>O", None, 0, None ),
   	    ( "/File/_Save",    "<control>S", None, 0, None ),
   	    ( "/File/Save _As", None,         None, 0, None ),
   	    ( "/File/sep1",     None,         None, 0, "<Separator>" ),
   	    ( "/File/Quit",     "<control>Q", self.cmd_exit, 0, None ),
            ( "/_View",		None,		None, 0, "<Branch>" ),
            ( "/View/_Zoom In",	"<control>equal", self.cmd_zoom_in, 0, None ),
            ( "/View/Zoom _Out", "<control>minus", self.cmd_zoom_out, 0, None ),
   	    ))
        menubar = self.item_factory.get_widget("<main>")
        vbox.add(menubar)
        menubar.show()

    def cmd_exit(self, *args):
        gtk.main_quit()

    def cmd_zoom_in(self, widget, event):
        self.plotbox.zoom_in()

    def cmd_zoom_out(self, widget, event):
        self.plotbox.set_time_range(None, None)


if __name__ == "__main__":
    try:
        if len(sys.argv) >= 2:
            window = PlotFlowWindow(sys.argv[1])
        else:
            window = PlotFlowWindow(sys.stdin)
        gtk.main()
    except KeyboardInterrupt:
        gtk.main_quit()
