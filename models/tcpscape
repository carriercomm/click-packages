#!/usr/bin/env python

from __future__ import generators
from bisect import bisect
import sys, re, types
from math import *
import gtk, pango

fill_colors = {
    "data": "red", "ack": "green", "dataack": "blue",
    "loss": "cornsilk1", "ploss": "mint cream", "floss": "blanched almond",
    "border": "grey", "lossborder": "yellow"
}
gc_dashes = {
    "lossborder": [4, 4]
}

def frange(start, stop, step):
    i = 0
    while True:
        pos = start + i * step
        if pos > stop:
            break
        yield pos
        i += 1

class Packet:
    def __init__(self, time, seq, seqlen, ack):
        self.time = float(time)
        self.seq = int(seq)
        self.last_seq = self.seq + int(seqlen)
        self.ack = int(ack)
    def pure_ack(self):
        return self.seq == self.last_seq
    def has_data(self):
        return self.seq != self.last_seq
    def __cmp__(self, other):
        return self.time.__cmp__(other.time)
    def __str__(self):
        result = "[" + `self.time` + " "
        if self.pure_ack():
            result += "A" + `self.ack`
        else:
            result += `self.seq` + ":" + `self.last_seq`
        return result + "]"

class LossEvent:
    def __init__(self, type, begin, seq, end, end_seq):
        self.type, self.begin, self.seq, self.end, self.end_seq = \
                   type, float(begin), int(seq), float(end), int(end_seq)
    def time_overlaps(self, begin, end):
        return (begin is None or self.end >= begin) and (end is None or end >= self.begin);
    def fillcolor(self):
        return fill_colors[self.type]


def direction(dir):
    if dir == '>':
        return 0
    elif dir == '<':
        return 1
    elif dir is True:
        return 0
    elif dir is False:
        return 1
    elif int(dir) == 0 or int(dir) == 1:
        return int(dir)
    else:
        raise RuntimeError, "bad direction " + `dir`


class Connection:
    def __init__(self, f=None):
        self.s = ([], [])
        self.loss = ([], [])
        self.flow_id = []
        self.aggregate = -1
        self.available = False
        if type(f) == types.FileType:
            self.read(f)
        else:
            self.filename = f
    def read(self, f):
        for line in f:
            if not re.match('[\\!\\#]', line):
                time, dir, flags, seq, seqlen, ack = line.split()
                self.s[direction(dir)].append(Packet(time, seq, seqlen, ack))
            elif re.match('\\#[pf]?loss', line):
                type, dir, time, seq, end_time, end_seq = line[1:].split()[:6]
                self.loss[direction(dir)].append(LossEvent(type, time, seq, end_time, end_seq))
            elif re.match('!flowid', line):
                self.flow_id = line.split()[1:]
            elif re.match('!aggregate', line):
                self.aggregate = int(line.split()[1])
            elif re.match('!eof$', line):
                break
        self.available = True
        return self
    def first_index_after(self, time, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            return self.first_index_after(time, 0), self.first_index_after(time, 1)
        else:
            fake_pkt = Packet(time, 0, 0, 0)
            return bisect(self.s[direction(dir)], fake_pkt)
    def packets(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        if begin is None:
            i = 0
        else:
            i = self.first_index_after(begin, dir)
        while i < len(self.s[dir]) and (end is None or self.s[dir][i].time <= end):
            yield self.s[dir][i]
            i += 1
    def losses(self, dir, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        for l in self.loss[dir]:
            if l.time_overlaps(begin, end):
                yield l
    def time_range(self, dir=None):
        if not self.available:
            self.load()
        if dir is None:
            return min(self.s[0][0].time, self.s[1][0].time), max(self.s[0][-1].time, self.s[1][-1].time)
        else:
            dir = direction(dir)
            return self.s[dir][0].time, self.s[dir][-1].time
    def _time_index(self, dir, time, after):
        if time is not None:
            return self.first_index_after(time, dir)
        elif after:
            return len(self.s[dir])
        else:
            return 0
    def _seq_range(self, dir, begin, end):
        s0, s1 = 1e10, None
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].seq - 20)
            s1 = max(s1, self.s[dir][i].last_seq + 20)
        for l in self.losses(dir, begin, end):
            s0 = min(s0, l.seq - 50)
            s1 = max(s1, l.end_seq + 50)
        return max(s0, 0), s1
    def _ack_range(self, dir, begin, end):
        s0, s1 = 1e10, None
        for i in range(self._time_index(dir, begin, False), self._time_index(dir, end, True)):
            s0 = min(s0, self.s[dir][i].ack - 20)
            s1 = max(s1, self.s[dir][i].ack + 20)
        return max(s0, 0), s1
    def seq_range(self, dir=None, begin=None, end=None):
        if not self.available:
            self.load()
        dir = direction(dir)
        r0, r1 = self._seq_range(dir, begin, end), self._ack_range(1 - dir, begin, end)
        return min(r0[0], r1[0]), max(r0[1], r1[1])
    def get_description(self):
        if not self.available:
            self.load()
        s = ""
        if self.aggregate >= 0:
            s += "Aggregate " + `self.aggregate` + ": "
        return s + self.flow_id[0] + ":" + self.flow_id[1] + " > " + self.flow_id[2] + ":" + self.flow_id[3]
    def load(self):
        if type(self.filename) != types.StringType:
            raise RuntimeError, "cannot load this Connection"
        elif not self.available:
            self.read(self.filename)
    def unload(self):
        if type(self.filename) == types.StringType:
            self.__init__(self.filename)


def fix_range(a, b, min_step_frac):
    d = b - a
    step = 10 ** floor(log10(d))

    # make step bigger if required
    if step / d > 0.5 and step / d >= min_step_frac:
        if step/5 / d >= min_step_frac:
            step /= 5
        elif step/2.5 / d >= min_step_frac:
            step /= 2.5
        elif step/2 / d >= min_step_frac:
            step /= 2
    while step < d and step / d < min_step_frac:
        if 2*step / d >= min_step_frac:
            step *= 2
        elif 2.5*step / d >= min_step_frac:
            step *= 2.5
        elif 5*step / d >= min_step_frac:
            step *= 5
        else:
            step *= 10
    if step >= d:
        step = d

    # bound a and b to multiples of step, if appropriate
    a_try = floor(a / step) * step
    if a - a_try < 0.1*d:
        a = a_try
    b_try = ceil(b / step) * step
    if b_try - b < 0.1*d:
        b = b_try
    else:
        b += 0.01*d
    
    # return a dictionary
    return { "low": a, "high": b, "step": step }


class PlotCanvas:
    def __init__(self, master, width=600, height=500):
        self.canvas = gtk.DrawingArea()
        self.canvas.set_size_request(width, height)

        self.canvas.connect("configure_event", self.cmd_configure)
        self.canvas.connect("expose_event", self.cmd_expose)
        self.canvas.connect("button_press_event", self.cmd_press)
        self.canvas.connect("button_release_event", self.cmd_release)
        self.canvas.connect("enter_notify_event", self.cmd_enter)
        self.canvas.connect("leave_notify_event", self.cmd_leave)
        self.canvas.set_events(gtk.gdk.EXPOSURE_MASK | gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK | gtk.gdk.ENTER_NOTIFY_MASK | gtk.gdk.LEAVE_NOTIFY_MASK)
        
        master.pack_start(self.canvas, expand=1, fill=1)
        self.canvas.show()

        self.left_margin = 40
        self.right_margin = 20
        self.top_margin = 10
        self.bottom_margin = 20
        self.gc = {}
        self.plotted = False
        self.press_x = None
    def set_connection(self, conn, dir, begin=None, end=None, duration=None):
        if begin is not None and duration is not None and end is None:
            end = begin + duration
        self.conn, self.dir, self.begin, self.end = conn, direction(dir), begin, end
        if self.plotted: self.plot()
    def set_direction(self, dir):
        self.dir = direction(dir)
        if self.plotted: self.plot()
    def get_connection(self):
        return self.conn
    def get_direction(self):
        return self.dir
    def cmd_configure(self, widget, event):
        x, y, self.wwidth, self.wheight = widget.get_allocation()

        if not self.gc.has_key("data"):
            cmap = self.canvas.get_colormap()
            for k in fill_colors.keys():
                self.gc[k] = self.canvas.window.new_gc(foreground=cmap.alloc_color(fill_colors[k]), line_width=0, cap_style=gtk.gdk.CAP_BUTT)
            for k in gc_dashes.keys():
                self.gc[k].line_style = gtk.gdk.LINE_ON_OFF_DASH
                self.gc[k].set_dashes(0, gc_dashes[k])
        
        self.plot_width = self.wwidth - self.left_margin - self.right_margin
        self.plot_height = self.wheight - self.top_margin - self.bottom_margin
    def cmd_expose(self, widget, event):
        self.plot()

    def _itransform(self, x, y):
        if self.plotted and x >= self.left_margin and x <= self.left_margin + self.plot_width and y >= self.top_margin and y <= self.top_margin + self.plot_height:
            return (x - self.toff) / self.tscale, (y - self.soff) / self.sscale
        else:
            raise ValueError
    def _trange(self):
        if self.plotted:
            return (self.left_margin - self.toff) / self.tscale, (self.left_margin + self.plot_width - self.toff) / self.tscale
        else:
            raise ValueError
    def cmd_press(self, widget, event):
        try:
            if event.button == 1:
                self.press_x, press_y = self._itransform(event.x, event.y)
        except ValueError:
            pass
        return 1
    def cmd_release(self, widget, event):
        try:
            if event.button == 1 and self.press_x is not None:
                press_x, y = self._itransform(event.x, event.y)
                if abs(press_x - self.press_x) > 5 / self.tscale:
                    self.begin = min(press_x, self.press_x)
                    self.end = max(press_x, self.press_x)
                    self.plot()
                else:
                    t0, t1 = self._trange()
                    new_dt = (t1 - t0) / 5
                    self.begin = press_x - new_dt * ((press_x - t0) / (t1 - t0))
                    if self.begin < 0: self.begin = 0
                    self.end = self.begin + new_dt
                    self.plot()
        except ValueError:
            pass
        self.press_x = None
        return 1
    def cmd_enter(self, widget, event):
        return 1
    def cmd_leave(self, widget, event):
        return 1

    # drawing helpers
    def _draw_label_y(self, text, pos, edge1, edge2, drawable, gc, playout):
        if re.match(".*e\\+0[4-7]$", text):
            text = str(float(text))[:-2]
        if re.match("...*000$", text):
            text = text[:-3] + "K"
        playout.set_text(text, -1)
        ir, lr = playout.get_extents()
        drawable.draw_layout(gc, edge1 - 4 - lr[2]/1024.0, pos - lr[3]/2048.0, playout)
    def _draw_label_x(self, text, pos, edge1, edge2, drawable, gc, playout):
        playout.set_text(text, -1)
        ir, lr = playout.get_extents()
        drawable.draw_layout(gc, pos - lr[2]/2048.0, edge2 + 2, playout)
    def _draw_tic_x(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, pos, edge1, pos, edge1 + len)
        drawable.draw_line(gc, pos, edge2, pos, edge2 - len)
    def _draw_tic_y(self, pos, edge1, edge2, len, drawable, gc):
        drawable.draw_line(gc, edge1, pos, edge1 + len, pos)
        drawable.draw_line(gc, edge2, pos, edge2 - len, pos)
    def _draw_axis(self, scale, off, pos1, pos2, step, edge1, edge2, ticer, labeller, drawable, gc, playout):
        if abs(step * scale) >= 50:
            mstep = step / 10
        else:
            mstep = step / 4
        for pos in frange(floor(pos1 / step) * step, pos2, step):
            pix = pos * scale + off
            if pos >= pos1:
                ticer(pix, edge1, edge2, 5, drawable, gc)
                labeller("%g" % pos, pix, edge1, edge2, drawable, gc, playout)
            for mpos in frange(pos + mstep, min(pos + step, pos2), mstep):
                mpix = mpos * scale + off
                if mpos >= pos1:
                    ticer(mpix, edge1, edge2, 2, drawable, gc)

    def plot(self, drawable=None):
        if drawable is None: drawable = self.canvas.window
        drawable.clear()
        if self.conn is not None:

            # analyze time and sequence ranges
            t0, t1 = self.begin, self.end
            if t0 is None:
                t0 = self.conn.time_range(self.dir)[0]
            if t1 is None:
                t1 = self.conn.time_range(self.dir)[1]
            s0, s1 = self.conn.seq_range(self.dir, t0, t1)
            if s0 is None or s1 is None:
                s0 = 0; s1 = 1

            # fix ranges
            ranges = fix_range(t0, t1, 30.0 / self.plot_width)
            t0, t1, tstep = ranges["low"], ranges["high"], ranges["step"]
            ranges = fix_range(s0, s1, 30.0 / self.plot_height)
            s0, s1, sstep = ranges["low"], ranges["high"], ranges["step"]

            # get transformation
            tscale = self.plot_width / float(t1 - t0)
            sscale = self.plot_height / float(s0 - s1)
            toff = self.left_margin - (t0 * tscale)
            soff = self.top_margin - (s1 * sscale)
            self.tscale, self.sscale, self.toff, self.soff = tscale, sscale, toff, soff

            # variables
            playout = self.canvas.create_pango_layout("")

            # clear background
            drawable.draw_rectangle(self.canvas.get_style().white_gc, gtk.TRUE, self.left_margin, self.top_margin, self.plot_width, self.plot_height)

            # losses
            gc = self.gc["lossborder"]
            for l in self.conn.losses(self.dir, t0, t1):
                x0 = max(t0, l.begin) * tscale + toff
                x1 = min(t1, l.end) * tscale + toff
                y0 = max(s0, l.seq) * sscale + soff
                y1 = min(s1, l.end_seq) * sscale + soff
                drawable.draw_rectangle(self.gc[l.type], gtk.TRUE, x0, y1, x1 - x0, y0 - y1)
                drawable.draw_rectangle(gc, gtk.FALSE, x0, y1, x1 - x0, y0 - y1)
            
            # border box
            gc = self.gc["border"]
            drawable.draw_rectangle(gc, gtk.FALSE, self.left_margin, self.top_margin, self.plot_width, self.plot_height)

            # axes major tics
            self._draw_axis(tscale, toff, t0, t1, tstep, self.top_margin, self.wheight - self.bottom_margin, self._draw_tic_x, self._draw_label_x, drawable, gc, playout)
            self._draw_axis(sscale, soff, s0, s1, sstep, self.left_margin, self.wwidth - self.right_margin, self._draw_tic_y, self._draw_label_y, drawable, gc, playout)
            
            # data packets
            gc = self.gc["data"]
            for p in self.conn.packets(self.dir, t0, t1):
                x, y, yy = p.time * tscale + toff, p.seq * sscale + soff, p.last_seq * sscale + soff
                drawable.draw_line(gc, x - 2, y, x + 3, y)
                drawable.draw_line(gc, x - 2, yy, x + 3, yy)
                drawable.draw_line(gc, x, y, x, yy)
            
            # ack packets
            gc1 = self.gc["ack"]; gc2 = self.gc["dataack"]
            for p in self.conn.packets(1 - self.dir, t0, t1):
                x, y = int(floor(p.time * tscale + toff)), int(floor(p.ack * sscale + soff))
                if p.pure_ack(): gc = gc1
                else: gc = gc2
                drawable.draw_line(gc, x - 2, y - 2, x + 2, y + 2)
                drawable.draw_line(gc, x - 2, y + 2, x + 2, y - 2)

            self.plotted = True

        else:
            self.plotted = False


class PlotBox:
    def __init__(self, master):
        self.frame = gtk.VBox()
        master.pack_start(self.frame, expand=1, fill=1)
        self.frame.show()
        
        self.lframe = gtk.HBox()
        self.frame.pack_start(self.lframe, expand=0, fill=0)
        self.lframe.show()
        self.l0 = gtk.Label("")
        self.dirbutton = gtk.Button(">")
        self.dirbutton.connect("clicked", self.cmd_dirbutton)
        self.l1 = gtk.Label("foo")
        self.lframe.pack_start(self.l0, expand=0, fill=0); self.l0.show()
        self.lframe.pack_start(self.dirbutton, expand=0, fill=0); self.dirbutton.show()
        self.lframe.pack_start(self.l1, expand=0, fill=0); self.l1.show()
        
        self.canvas = PlotCanvas(self.frame)
    def cmd_dirbutton(self, *args):
        self.set_connection(self.canvas.get_connection(), 1 - self.canvas.get_direction())
    def set_connection(self, conn, dir=0):
        self.canvas.set_connection(conn, dir)
        desc = conn.get_description()
        mid = desc.find(' > ')
        self.l0.set_label(desc[:mid + 1])
        self.l1.set_label(desc[mid + 2:])
        self.dirbutton.set_label("><"[self.canvas.get_direction()])
    def pack(self, *args, **keys):
        self.frame.pack(*args, **keys)


class PlotFlowWindow:
    def __init__(self):
        win = gtk.Window()
        win.connect('destroy', self.exit_command)
        win.set_title("PlotFlow")

        vbox = gtk.VBox()
        win.add(vbox)
        vbox.show()

        # the plotbox
        self.plotbox = PlotBox(vbox)

        c = Connection(sys.stdin)
        self.plotbox.set_connection(c, '>')

        win.show()
        
    def exit_command(self, event=None):
        gtk.main_quit()


if __name__ == "__main__":
    window = PlotFlowWindow()
    gtk.main()
